---
layout:     post
title:      "Java中JVM的原理（下）"
subtitle:   "垃圾收集器与内存分配策略"
date:       2017-02-18 19:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - Java
---

> 谈谈Java虚拟机如何回收内存


## 前言

上一篇文章我们对JVM有了一个粗略地认识，这一篇我们就讲一讲垃圾收集器和内存分配策略。

---

## 正文

JVM内存回收 

Sun的JVMGenerationalCollecting(垃圾回收)原理是这样的：把对象分为年青代(Young)、年老代(Tenured)、持久代(Perm)，对不同生命周期的对象使用不同的[算法](http://lib.csdn.net/base/datastructure)。(基于对对象生命周期分析)

 ![img](http://images.cnitblog.com/blog/502866/201402/241536330131652.jpg)

**1.Young（年轻代）**

年轻代分三个区。一个Eden区，两个Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制年老区(Tenured。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。

**2.Tenured（年老代）**

年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象。

**3.Perm（持久代）**

用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如[hibernate](http://lib.csdn.net/base/javaee)等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。

举个例子：当在程序中生成对象时，正常对象会在年轻代中分配空间，如果是过大的对象也可能会直接在年老代生成（据观测在运行某程序时候每次会生成一个十兆的空间用收发消息，这部分内存就会直接在年老代分配）。年轻代在空间被分配完的时候就会发起内存回收，大部分内存会被回收，一部分幸存的内存会被拷贝至Survivor的from区，经过多次回收以后如果from区内存也分配完毕，就会也发生内存回收然后将剩余的对象拷贝至to区。等到to区也满的时候，就会再次发生内存回收然后把幸存的对象拷贝至年老区。

通常我们说的JVM内存回收总是在指堆内存回收，确实只有堆中的内容是动态申请分配的，所以以上对象的年轻代和年老代都是指的JVM的Heap空间，而持久代则是之前提到的MethodArea，不属于Heap。

## 关于JVM内存管理的一些建议

1、手动将生成的无用对象，中间对象置为null，加快内存回收。

2、对象池技术如果生成的对象是可重用的对象，只是其中的属性不同时，可以考虑采用对象池来较少对象的生成。如果有空闲的对象就从对象池中取出使用，没有再生成新的对象，大大提高了对象的复用率。

3、JVM调优通过配置JVM的参数来提高垃圾回收的速度，如果在没有出现内存泄露且上面两种办法都不能保证JVM内存回收时，可以考虑采用JVM调优的方式来解决，不过一定要经过实体机的长期[测试](http://lib.csdn.net/base/softwaretest)，因为不同的参数可能引起不同的效果。如-Xnoclassgc参数等。

## 后记




