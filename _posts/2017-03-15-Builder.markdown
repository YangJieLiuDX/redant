---
layout:     post
title:      "设计模式之建造者模式"
subtitle:   "针对复杂对象的创建型模式"
date:       2017-03-15 16:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 设计模式
---

> 将构建和表示进行分离~~~


## 前言

终于遇到一个非工厂模式的设计模式了，它就是建造者模式，这一篇文章就让我们一起来聊一下它！

---

## 正文

**什么是建造者模式**

建造者模式将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同表示。它一步一步创建复杂对象，允许用户通过指定复杂对象类型和内容构建它们，而不需知道具体细节。建造者模式有如下角色：

- Product：一般是复杂对象，即创建过程复杂，有较多代码量。产品类可以由一个抽象类与它的不同实现组成，也可以由多个抽象类与他们的实现组成
- Builder：将建造具体过程交与其子类来实现。一般至少有两个抽象方法，一个建造产品，一个返回产品
- ConcreteBuilder：实现抽象类未实现方法，一般是两项任务：组建产品；返回产品
- Director：负责调用适当建造者组建产品，与导演类直接交互的是建造者类

**怎么使用建造者模式**

例：建造者模式可以用于描述KFC如何创建套餐：套餐包含主食（如汉堡、鸡肉卷）和饮料（如果汁、可乐）等，不同套餐有不同组成部分，而服务员可以根据顾客要求，一步一步装配这些部分，构造完整套餐，然后返回给顾客

***步骤一：创建Product***

```java
package com.builder;

public class Meal {

	private String food;
	private String drink;

	public String getFood() {
		return food;
	}

	public void setFood(String food) {
		this.food = food;
	}

	public String getDrink() {
		return drink;
	}

	public void setDrink(String drink) {
		this.drink = drink;
	}

}
```

***步骤二：创建Builder***

```java
package com.builder;

public abstract class MealBuilder {

	Meal meal = new Meal();

	public abstract void buildFood();

	public abstract void buildDrink();

	public Meal getMeal() {
		return meal;
	}

}
```

***步骤三：创建ConcreteBuilder***

MealA类：

```java
package com.builder;

public class MealA extends MealBuilder {

	@Override
	public void buildFood() {
		meal.setDrink("一杯可乐");
	}

	@Override
	public void buildDrink() {
		meal.setFood("一盒薯条");
	}

}
```

MealB类：

```c
package com.builder;

public class MealB extends MealBuilder {

	@Override
	public void buildFood() {
		meal.setDrink("一杯柠檬果汁");
	}

	@Override
	public void buildDrink() {
		meal.setFood("三个鸡翅");
	}

}
```

***步骤四：创建Director***

```c
package com.builder;

public class KFCWaiter {
	private MealBuilder mealBuilder;

	public void setMealBuilder(MealBuilder mealBuilder) {
		this.mealBuilder = mealBuilder;
	}

	public Meal construct() {
		mealBuilder.buildFood();
		mealBuilder.buildDrink();
		return mealBuilder.getMeal();
	}
}
```

***步骤五：创建Client***

```c
package com.builder;

public class Client {
	public static void main(String[] args) {
		KFCWaiter waiter = new KFCWaiter();
		MealA a = new MealA();
		waiter.setMealBuilder(a);
		Meal mealA = waiter.construct();
		System.out.print("套餐A的组成部分:");
		System.out.println(mealA.getFood() + "和" + mealA.getDrink());
	}
}
```
**建造者模式有哪些优缺点**

***优点***

- 客户端不必知道产品内部组成细节，将产品本身与产品创建过程解耦，使得相同创建过程可以创建不同产品
- 具体建造者相对独立，可以很方便地替换具体建造者或增加新的具体建造者
- 将复杂产品的创建步骤分解在不同方法中，使得创建过程更加清晰，也方便使用程序来控制创建过程
- 增加新的具体建造者无须修改原有类库代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则

***缺点***

- 创建产品一般具有较多共同点，组成部分相似，如果产品差异性大，则不适合用建造者模式，因此使用范围有限
- 如果产品内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统庞大

**建造者模式适用于什么环境**

- 需要生成的产品对象有复杂的内部结构，包含多个成员属性
- 需要生成的产品对象的属性相互依赖，需要指定生成顺序
- 对象创建过程独立于创建对象的类。建造者模式引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中
- 隔离复杂对象的创建和使用，并使得相同创建过程可以创建不同产品

**有哪些例子属于建造者模式**

- 在很多游戏软件中，地图包括天空、地面等组成部分，人物包括人体、服装等组成部分，可以用建造者模式进行设计，通过不同具体建造者创建不同类型的地图或人物


## 后记

实际上，建造者模式在Android的Dialog中也有所应用，有兴趣的朋友可以去看一下。