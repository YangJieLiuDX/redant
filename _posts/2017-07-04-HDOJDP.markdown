---
layout:     post
title:      "杭电OJ刷题记之动态规划"
subtitle:   "算法中的常客"
date:       2017-07-04 14:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 数据结构与算法
---

> 学习算法逃不过去的一关
>


## 前言

动态规划在算法中有着极其重要的地位，也经常在各种算法比赛中出现，我们就通过这篇文章来对其进行一个简单的学习。

---

## 正文

**最大连续子序列和**

***题目来源***

[HDOJ 1003 Max Sum](http://acm.hdu.edu.cn/showproblem.php?pid=1003)

***题目分析***

这道题目算是动态规划题目里面比较简单的了。动态规划很重要的一步是找出动态转移方程，这里的动态转移方程是：`sum[i] = max{sum[i-1]+a[i],a[i]}`，根据这道方程，我们可以在O(n)的复杂度下求得各个节点的sum值，从而得到最大连续子序列和。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>

int main() {
    int t;
    scanf("%d", &t);
    for(int i = 0; i < t; i++) {
        int n;
        int *s, *sum, max;
        int a, b, A, B;
        scanf("%d", &n);
        s = (int *)malloc(sizeof(int) * n);
        sum = (int *)malloc(sizeof(int) * n);
        for(int j = 0; j < n; j++) {
            scanf("%d", &s[j]);
            sum[j] = 0;
        }
        if(i != 0) {
            printf("\n");
        }
        max = sum[0] = s[0];
        A = B = a = b = 0;
        for(int j = 1; j < n; j++) {
            if(sum[j - 1] + s[j] >= s[j]) {
                sum[j] = sum[j - 1] + s[j];
                b++;
            } else {
                sum[j] = s[j];
                a = b = j;
            }
            if(sum[j] > max) {
                max = sum[j];
                A = a;
                B = b;
            }
        }
        printf("Case %d:\n%d %d %d\n", i+1, max, A + 1, B + 1);
    }
    return 0;
}
```
**星河战队**

***题目来源***

[HDOJ 1011 Starship Troopers](http://acm.hdu.edu.cn/showproblem.php?pid=1011)

***题目分析***

这道题比上一道题复杂了很多，它不仅是动态规划，而且是树形的动态规划，可以说是01背包问题的升级版。但只要我们围绕着动态规划的核心思想出发，就能够解决问题。首先，问题可以定义为在第u个点使用j个士兵能得到大脑的最大可能性，接着根据题意得到状态转移方程：`value[u][j] = max{value[v][j], value[v][j-k]+value[v][k]}`，`value[u][j]`表示的是第u个点使用j个士兵能得到大脑的最大可能性，v表示的是u的所有子节点，最后得到的`value[1][m]`就是所求的最大可能性。由于需要从子节点推出父节点的值，所以整体采用后序遍历的方式。另外，`m=0`是一种特殊的情况，需要特殊考虑。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>
#define N 101

typedef struct {
    int bugs;
    int brains;
} room;

int n, m;
room rooms[N];
int matrix[N][N];
int visited[N];
int value[N][N];

void dpTree(int u) {
    int r;
    visited[u] = 1;
    r = (rooms[u].bugs + 19) / 20;
    for(int i = m; i >= r; i--) {
        value[u][i] = rooms[u].brains;
    }
    for(int v = 1; v <= n; v++) {
        if(matrix[u][v] && !visited[v]) {
            dpTree(v);
            for(int j = m; j >= r; j--) {
                for(int k = 1; k <= j - r; k++) {
                    if(value[u][j - k] + value[v][k] > value[u][j]) {
                        value[u][j] = value[u][j - k] + value[v][k];
                    }
                }
            }
        }
    }
}

int main() {
    while(scanf("%d %d", &n, &m) == 2 && n >= 0 && m >= 0) {
        memset(rooms, 0, sizeof(rooms));
        memset(matrix, 0, sizeof(matrix));
        memset(visited, 0, sizeof(visited));
        memset(value, 0, sizeof(value));
        for(int i = 1; i <= n; i++) {
            scanf("%d %d", &rooms[i].bugs, &rooms[i].brains);
        }
        for(int i = 1; i <= n - 1; i++) {
            int x, y;
            scanf("%d %d", &x, &y);
            matrix[x][y] = matrix[y][x] = 1;
        }
        if(m == 0) {
            printf("0\n");
        } else {
            dpTree(1);
            printf("%d\n", value[1][m]);
        }
    }
    return 0;
}
```

**星河战队**

***题目来源***

[HDOJ 1024 Max Sum Plus Plus](http://acm.hdu.edu.cn/showproblem.php?pid=1024)

***题目分析***

这道题比上道题难了很多，它不仅要考虑状态转移方程，而且还要考虑到优化问题。接下来让我们一起来解决这个问题：

1. 首先我们找到状态转移方程，即`s[i][j] = max{s[i][j-1] + num[j], s[i-1][k] + num[j]}`，其中`s[i][j]`表示 i 个不相交子段以及 j 个数下的最大值，max函数中的第一个表达式表示第 i 个子段包含`num[j]`，而后一个表达式表示不包含，k的取值范围为 i-1 到 j-1。最后所求的最大值为`max{s[m][j]}`
2. 如果直接按这个状态转移方程进行计算的话，时间复杂度和空间复杂度都会太大。我们通过观察状态转移方程可以看到，整个状态转移方程只涉及到 i 和 i-1 两种情况，所以我们可以把状态转移方程简化为：`s[1][j] = max{s[1][j-1] + num[j], s[0][k] + num[j]}`
3. 这样子，空间复杂度直接降了一个维度，但时间复杂度没降，依旧为O(m\*n\*n)。通过观察，我们发现只能处理最后一个维度，即对 k 的遍历。为了消灭这个维度，我们可以创建一个数组max[j]，保存上一个子段值计算时到 j 的最大值。通过这个操作，我们也可以直接把 s 这个二维数组降成一维

***实现代码***

```c
#include<stdio.h>
#include<string.h>
#define N 1000001

int m, n;
int num[N];
int s[N];
int max[N];

int main() {
    while(scanf("%d%d", &m, &n) == 2) {
        for(int i = 1; i <= n; i++) {
            scanf("%d", &num[i]);
        }
        memset(s, 0, sizeof(s));
        memset(max, 0, sizeof(max));
        for(int i = 1; i <= m; i++) {
            for(int j = i; j <= n; j++) {
                s[j] = s[j - 1] + num[j];
                if(max[j - 1] + num[j] > s[j]) {
                    s[j] = max[j - 1] + num[j];
                }
            }
            max[i] = s[i];
            for(int j = i + 1; j <= n; j++) {
                max[j] = max[j - 1];
                if(s[j] > max[j]) {
                    max[j] = s[j];
                }
            }
        }
        printf("%d\n", max[n]);
    }
    return 0;
}
```

## 后记

动态规划是我个人觉得算法中最有趣最有挑战性的题目，所以也建议大家要好好掌握。
