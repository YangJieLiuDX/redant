---
layout:     post
title:      "杭电OJ刷题记之动态规划"
subtitle:   "算法中的常客"
date:       2017-07-04 14:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 数据结构与算法
---

> 学习算法逃不过去的一关
>


## 前言

动态规划在算法中有着极其重要的地位，也经常在各种算法比赛中出现，我们就通过这篇文章来对其进行一个简单的学习。

---

## 正文

**最大连续子序列和**

***题目来源***

[HDOJ 1003 Max Sum](http://acm.hdu.edu.cn/showproblem.php?pid=1003)

***题目分析***

这道题目算是动态规划题目里面比较简单的了。动态规划很重要的一步是找出动态转移方程，这里的动态转移方程是：`sum[i] = max{sum[i-1]+a[i],a[i]}`，根据这道方程，我们可以在O(n)的复杂度下求得各个节点的sum值，从而得到最大连续子序列和。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>

int main() {
    int t;
    scanf("%d", &t);
    for(int i = 0; i < t; i++) {
        int n;
        int *s, *sum, max;
        int a, b, A, B;
        scanf("%d", &n);
        s = (int *)malloc(sizeof(int) * n);
        sum = (int *)malloc(sizeof(int) * n);
        for(int j = 0; j < n; j++) {
            scanf("%d", &s[j]);
            sum[j] = 0;
        }
        if(i != 0) {
            printf("\n");
        }
        max = sum[0] = s[0];
        A = B = a = b = 0;
        for(int j = 1; j < n; j++) {
            if(sum[j - 1] + s[j] >= s[j]) {
                sum[j] = sum[j - 1] + s[j];
                b++;
            } else {
                sum[j] = s[j];
                a = b = j;
            }
            if(sum[j] > max) {
                max = sum[j];
                A = a;
                B = b;
            }
        }
        printf("Case %d:\n%d %d %d\n", i+1, max, A + 1, B + 1);
    }
    return 0;
}
```
**星河战队**

***题目来源***

[HDOJ 1011 Starship Troopers](http://acm.hdu.edu.cn/showproblem.php?pid=1011)

***题目分析***

这道题比上一道题复杂了很多，它不仅是动态规划，而且是树形的动态规划，可以说是01背包问题的升级版。但只要我们围绕着动态规划的核心思想出发，就能够解决问题。首先，问题可以定义为在第u个点使用j个士兵能得到大脑的最大可能性，接着根据题意得到状态转移方程：`value[u][j] = max{value[v][j], value[v][j-k]+value[v][k]}`，`value[u][j]`表示的是第u个点使用j个士兵能得到大脑的最大可能性，v表示的是u的所有子节点，最后得到的`value[1][m]`就是所求的最大可能性。由于需要从子节点推出父节点的值，所以整体采用后序遍历的方式。另外，`m=0`是一种特殊的情况，需要特殊考虑。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>
#define N 101

typedef struct {
    int bugs;
    int brains;
} room;

int n, m;
room rooms[N];
int matrix[N][N];
int visited[N];
int value[N][N];

void dpTree(int u) {
    int r;
    visited[u] = 1;
    r = (rooms[u].bugs + 19) / 20;
    for(int i = m; i >= r; i--) {
        value[u][i] = rooms[u].brains;
    }
    for(int v = 1; v <= n; v++) {
        if(matrix[u][v] && !visited[v]) {
            dpTree(v);
            for(int j = m; j >= r; j--) {
                for(int k = 1; k <= j - r; k++) {
                    if(value[u][j - k] + value[v][k] > value[u][j]) {
                        value[u][j] = value[u][j - k] + value[v][k];
                    }
                }
            }
        }
    }
}

int main() {
    while(scanf("%d %d", &n, &m) == 2 && n >= 0 && m >= 0) {
        memset(rooms, 0, sizeof(rooms));
        memset(matrix, 0, sizeof(matrix));
        memset(visited, 0, sizeof(visited));
        memset(value, 0, sizeof(value));
        for(int i = 1; i <= n; i++) {
            scanf("%d %d", &rooms[i].bugs, &rooms[i].brains);
        }
        for(int i = 1; i <= n - 1; i++) {
            int x, y;
            scanf("%d %d", &x, &y);
            matrix[x][y] = matrix[y][x] = 1;
        }
        if(m == 0) {
            printf("0\n");
        } else {
            dpTree(1);
            printf("%d\n", value[1][m]);
        }
    }
    return 0;
}
```

**最大连续子序列和升级版**

***题目来源***

[HDOJ 1024 Max Sum Plus Plus](http://acm.hdu.edu.cn/showproblem.php?pid=1024)

***题目分析***

这道题比上道题难了很多，它不仅要考虑状态转移方程，而且还要考虑到优化问题。接下来让我们一起来解决这个问题：

1. 首先我们找到状态转移方程，即`s[i][j] = max{s[i][j-1] + num[j], s[i-1][k] + num[j]}`，其中`s[i][j]`表示 i 个不相交子段以及 j 个数下的最大值，max函数中的第一个表达式表示第 i 个子段包含`num[j]`，而后一个表达式表示不包含，k的取值范围为 i-1 到 j-1。最后所求的最大值为`max{s[m][j]}`
2. 如果直接按这个状态转移方程进行计算的话，时间复杂度和空间复杂度都会太大。我们通过观察状态转移方程可以看到，整个状态转移方程只涉及到 i 和 i-1 两种情况，所以我们可以把状态转移方程简化为：`s[1][j] = max{s[1][j-1] + num[j], s[0][k] + num[j]}`
3. 这样子，空间复杂度直接降了一个维度，但时间复杂度没降，依旧为O(m\*n\*n)。通过观察，我们发现只能处理最后一个维度，即对 k 的遍历。为了消灭这个维度，我们可以创建一个数组max[j]，保存上一个子段值计算时到 j 的最大值。通过这个操作，我们也可以直接把 s 这个二维数组降成一维

***实现代码***

```c
#include<stdio.h>
#include<string.h>
#define N 1000001

int m, n;
int num[N];
int s[N];
int max[N];

int main() {
    while(scanf("%d%d", &m, &n) == 2) {
        for(int i = 1; i <= n; i++) {
            scanf("%d", &num[i]);
        }
        memset(s, 0, sizeof(s));
        memset(max, 0, sizeof(max));
        for(int i = 1; i <= m; i++) {
            for(int j = i; j <= n; j++) {
                s[j] = s[j - 1] + num[j];
                if(max[j - 1] + num[j] > s[j]) {
                    s[j] = max[j - 1] + num[j];
                }
            }
            max[i] = s[i];
            for(int j = i + 1; j <= n; j++) {
                max[j] = max[j - 1];
                if(s[j] > max[j]) {
                    max[j] = s[j];
                }
            }
        }
        printf("%d\n", max[n]);
    }
    return 0;
}
```

**道路问题**

***题目来源***

[HDOJ 1025 Constructing Roads In JGShining's Kingdom](http://acm.hdu.edu.cn/showproblem.php?pid=1025)

***题目分析***

这道题稍微分析一下，就可以判断出它是属于LIS问题，即最长递增子串问题。对于LIS问题，主要的解决方法有时间复杂度为O(n\*n)的动态规划法和时间复杂度为为O(n\*logn)的LIS算法。

由于本题数据量较大，所以第一种方法会出现TLE的情况，但我们也稍微提一下。所谓动态规划，最重要的是要找到状态转移方程。这道题的状态转移方程是：`s[i] = max{s[k]} + 1, 0 <= k < i, num[k] < num[i]`。这个状态转移方程比较好理解，代码也比较好些，但由于此题不可行，所以并不赘述。

另一种方法是LIS算法，它的具体思路是增加一个数组s，s[i]表示长度为 i 的最长子序列的最后一个数最小可以是多少。然后对输入数组进行遍历，如果该数大于最后一个元素，则进行添加，否则替换数组中第一个大于该元素的元素。对于这个替换操作，我们可以用二分查找来降低时间复杂度。实际上，整个思路很接近于对栈的操作。

***实现代码***

```c
#include<stdio.h>
#include<algorithm>
#define N 500001
using namespace std;

typedef struct {
    int x;
    int y;
} road;

int n, m;
road roads[N];
int s[N];

int cmp(road r1, road r2) {
    return r1.x < r2.x;
}

int main() {
    int nCases = 1;
    while(scanf("%d", &n) == 1) {
        for(int i = 0; i < n; i++) {
            scanf("%d%d", &roads[i].x, &roads[i].y);
        }
        sort(roads, roads + n, cmp);
        s[0] = 0;
        s[1] = roads[0].y;
        m = 1;
        for(int i = 1; i < n; i++) {
            if(roads[i].y > s[m]) {
                s[++m] = roads[i].y;
            } else {
                int low = 0, high = m;
                int mid = low + (high - low) / 2;
                while(low < high - 1) {
                    if(roads[i].y > s[mid]) {
                        low = mid;
                    } else {
                        high = mid;
                    }
                    mid = low + (high - low) / 2;
                }
                s[high] = roads[i].y;
            }
        }
        printf("Case %d:\nMy king, at most %d road", nCases++, m);
        if(m != 1) {
            printf("s");
        }
        printf(" can be built.\n\n");
    }
    return 0;
}
```

**我需要一个Offer**

***题目来源***

[HDOJ 1203 I NEED A OFFER!](http://acm.hdu.edu.cn/showproblem.php?pid=1203)

***题目分析***

这题本质上是01背包问题，只不过我们需要修改其中一些细节。在这道题中，状态转移方程是`f[v] = min(f[v], f[v- a[i]] * (1 - b[i]))`，其中`f[v]`表示的是当资金为v的时候没有Offer的概率，因为最后要求拿到Offer的最大概率，所以这里求的是最小概率。另外，`f[v]`的所有元素需初始化为1，因为刚开始的时候没有学校可选择，所以无论资金多少，拿到Offer的概率都为0。此题还有两个小细节：一个是无法使用`memset`函数，因为其只适用于int类型的数组，另一个细节是要输出`%`，格式应为`%%`。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int n, m;
int *a;
double *b;
double *f;

int main() {
    while(scanf("%d%d", &n, &m) == 2) {
        if(m == 0 && n == 0) {
            break;
        }
        a = (int *)malloc(sizeof(int) * (m + 1));
        b = (double *)malloc(sizeof(double) * (m + 1));
        f = (double *)malloc(sizeof(double) * (n + 1));
        for(int i = 0; i <= n; i++) {
            f[i] = 1;
        }
        for(int i = 1; i <= m; i++) {
            scanf("%d%lf", &a[i], &b[i]);
        }
        for(int i = 1; i <= m; i++) {
            for(int j = n; j >= a[i]; j--) {
                f[j] = f[j] < f[j - a[i]] * (1 - b[i]) ? f[j] : f[j - a[i]] * (1 - b[i]);
            }
        }
        printf("%.1lf%%\n", (1 - f[n]) * 100);
    }
    return 0;
}
```

**悼念512汶川大地震遇难同胞——珍惜现在，感恩生活**

***题目来源***

[HDOJ 2191 悼念512汶川大地震遇难同胞——珍惜现在，感恩生活](http://acm.hdu.edu.cn/showproblem.php?pid=2191)

***题目分析***

表面上物品是多件的，但因为件数有限，所以我们可以用01背包的思路解决。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int C;
int n, m;
int *p, *h, *c;
int *f;

int main() {
    scanf("%d", &C);
    while(C--) {
        scanf("%d%d", &n, &m);
        p = (int *)malloc(sizeof(int) * (m + 1));
        h = (int *)malloc(sizeof(int) * (m + 1));
        c = (int *)malloc(sizeof(int) * (m + 1));
        f = (int *)malloc(sizeof(int) * (n + 1));
        memset(f, 0, (n + 1)*sizeof(int));
        for(int i = 1; i <= m; i++) {
            scanf("%d%d%d", &p[i], &h[i], &c[i]);
        }
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= c[i]; j++) {
                for(int k = n; k >= p[i]; k--) {
                    f[k] = f[k] > f[k - p[i]] + h[i] ? f[k] : f[k - p[i]] + h[i];
                }
            }
        }
        printf("%d\n", f[n]);
    }
    return 0;
}
```

**拾骨者**

***题目来源***

[HDOJ 2602 Bone Collector](http://acm.hdu.edu.cn/showproblem.php?pid=2602)

***题目分析***

典型的01背包问题，直接解决即可。

***实现代码***

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int t, n, v;
int *c, *w;
int *f;

int main() {
    scanf("%d", &t);
    while(t--) {
        scanf("%d%d", &n, &v);
        c = (int *)malloc(sizeof(int) * (n + 1));
        w = (int *)malloc(sizeof(int) * (n + 1));
        f = (int *)malloc(sizeof(int) * (v + 1));
        memset(f, 0, (v + 1) * sizeof(int));
        for(int i = 1; i <= n; i++) {
            scanf("%d", &w[i]);
        }
        for(int i = 1; i <= n; i++) {
            scanf("%d", &c[i]);
        }
        for(int i = 1; i <= n; i++) {
            for(int j = v; j >= c[i]; j--) {
                f[j] = f[j] > f[j - c[i]] + w[i] ? f[j] : f[j - c[i]] + w[i];
            }
        }
        printf("%d\n", f[v]);
    }
    return 0;
}
```

## 后记

动态规划是我个人觉得算法中最有趣最有挑战性的题目，所以也建议大家要好好掌握。
