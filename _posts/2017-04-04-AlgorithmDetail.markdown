---
layout:     post
title:      "算法的细枝末节"
subtitle:   "程序的精髓——算法"
date:       2017-04-04 17:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 数据结构与算法
---

> 从2017年4月写起的算法笔记


## 前言

4月份的第一篇文章，送给程序员永远不可忽略的算法。算法是个有趣的东西，也是个折磨人的东西，在学习编码过程中，我会不时接触到关于算法的一些小问题，就用这篇文章来总结一下吧！

---

## 正文

**怎样快速得知一个数是否是2的幂，如果是，又是2的几次方**

2的幂次方写成二进制后是1后面跟n个0，所以我们可以用`(number & number - 1) == 0`（这个式子左边的两个运算符都是遵循从右到左的运算规则）来进行判断，而几次方则需利用循环或递归获取，具体代码如下：

```c
#include <stdio.h>
#include <stdlib.h>

// 递归判断一个数是2的多少次方
int log2(int value) {
    if (value == 1)
        return 0;
    else
        return 1 + log2(value >> 1);
}

int main(void) {
    int num;
    scanf("%d", &num);
    if(num & (num - 1))
        printf("%d不是2的幂次方\n", num);
    else
        printf("%d是2的%d次方\n", num, log2(num));
    return 0;
}
```

**求一个二进制数中1的个数**

通过上面的例子，我们可以发现，`(number & number - 1)`能移除掉二进制中最右边的1，循环移除，可以将1全部移除，利用这一点我们可以求一个二进制数中1的个数，代码如下：

```c
int Func(int data) { 
    int count = 0;  
    while (data) {  
        data = data & (data-1);  
        count++;  
    }  
    return count;  
}
```

利用上面这个函数，我们还可以求出A和B的二进制中有多少位不相同，具体做法为：

1. 将A和B异或得到C，即C=A^B
2. 计算C的二进制中有多少个1

**怎么在O(n)的时间复杂度要求下，完成对0-n二进制中1的计数**

这个问题是对上面那个问题的变种，如果按照上面的方法，求每个数的二进制形式中1的个数需要的时间将与其本身带有1的个数所决定，所以每个数不可能在O(1)的时间复杂度下完成1的计数，也就不可能在遍历下达到O(n)的时间复杂度，那么怎样解决呢？

第一种方法是让后面的数通过前面的数求出其二进制数中1的个数。通过上例我们知道，每做一次`k & (k - 1)`的操作，都会得到一个比本身小，且1的个数为本身1的个数减一的数，所以利用这一点我们可以写出以下程序解决问题：

```c
result[0] = 0
for(int k = 0; k <= n; k++)
    result[k] = result[k & (k - 1)] + 1;
```

还有一种方法是观察规律写出相应的程序。通过写出前面的一些数，我们可以发现1的个数和2的幂存在着一些关系，所以根据这点我们可以写出以下代码：

```c
result[0] = 0;
for (int powerOfTwo = 1; powerOfTwo < n; powerOfTwo *= 2) {
    for (int i = 0; i < powerOfTwo; i++) {
        result[powerOfTwo + i] = result[i] + 1;
    }
}
```

实际上，这道题的解决方法有好几个，我也是从stackoverflow上的问题得到了灵感，具体可以点击[问题地址](http://stackoverflow.com/questions/43007574/how-to-count-the-number-of-1-bits-set-in-0-1-2-n-in-on-time)查看。

**如何求绝对众数**

所谓绝对众数，就是出现次数为整个数组大小一半还多的数，因此，绝对众数是唯一的。删除数组中两个不同的数，绝对众数不变，所以我们可以用以下方法来求解绝对众数：

```c
int Mode(int* a, int size) {
    int count = 0;
    int m = a[0];
    for (int i = 0; i < size; i++) {
        if (count == 0) {
            m = a[i];
            count = 1;
        } else if (m != a[i]) {
            count--;
        } else {
            count++;
        }
    }
    return m;
}
```

对于这种方法，时间复杂度为O(n)，如果求一般众数，一般要用基于比较的排序方法，所以时间复杂度为O(nlogn)，如果已知数值范围，则可利用哈希法把复杂度降低至O(n)。

**如何计算二分查找中的中值**

这个问题乍看起来很简单，相信会有一部分人的答案脱口而出。`mid = (low + high) / 2`是我们很常见的求中值的写法，包括在《算法导论》等很知名的专业书籍上也是这样写的，然后这个写法却存在Bug，因为它有溢出的可能性，所以现在推崇的是另一种求法：`mid = low + (high – low) / 2`或`mid = low + (high – low) >> 1`，这种求法与上面提到的解法从数学上求解到的结果是一样的，可以通过取整函数证明，但是后者保证不会出现比high还大的值，所以更为安全。

从这个问题我们也可以看出，往往更简单的问题隐藏着更深的知识。Knuth也在他的《Sorting and Searching》一书中提过，第一个二分查找程序在1946年已经公布，但是到了1962年才出现第一个没有BUG的二分查找程序，期间经历了16年的时间。因此，这个问题也警示着我们不会轻视那些表面看起来简单的问题。

**如何进行累加求和**

这是一个很简单也很经典的问题。当我们学编程后第一次遇到这个问题的时候，我们可能正在学递归或者循环，然后就可能直接用递归或循环解决了。然而当局者迷，这时候我们曾经的数学老师可能会生气地跳出来说：“把我教给你的都还给我了？直接代公式就可以了”。是的，一道简单的公式`sum(n) = n * (n + 1) / 2`就可以解决了，这可以把计算量从n直接降到1。那么这道问题是不是到此就结束了呢？不是的，从数学的角度来讲是结束了，但从计算机程序的角度来说还没有。上面这条公式存在着溢出的可能性，因为`n * (n + 1)`的数值可能过大。因此，我们需根据n的奇偶性来改进程序：

```c
#include<stdio.h>

int main() {
    int n;
    while(scanf("%d", &n) == 1) {
        if(n % 2 == 1) {
            printf("%d\n\n", (n + 1) / 2 * n);
        } else {
            printf("%d\n\n", n / 2 * (n + 1));
        }
    }
    return 0;
}
```

## 后记

算法很容易被过于重视，也很容易被过于忽视，认识到自己需要的，才能更好的把握学习算法的时间投入。


