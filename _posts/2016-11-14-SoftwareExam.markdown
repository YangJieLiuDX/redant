---
layout:     post
title:      "软考知识点总结"
subtitle:   "复习软考走过的道路"
date:       2016-11-14 19:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 计算机基础
---

> 软考复习必备资料~~


## 前言

最近博主参加了中级软件设计师的考试，这个考试在大家眼里肯定是小菜一碟。在复习的过程中，笔者也是借此机会巩固了计算机基础知识。无论是开发还是学术研究，计算机基础知识都显得无比重要。通过这篇文章，笔者分享一下本人在复习过程中的笔记。

---

## 正文

软考的知识点范围包括软件工程与UML、计算机网络、数据结构与算法、计算机组成原理以及操作系统等等，接下来就从这几个方面对笔记进行整理。

#### 计算机组成原理

**冯诺依曼计算机**

计算机主要分为五个部分：控制器、运算器、 存储器、输入以及输出。其中运算器和控制器共同组成了CPU。

**指令寻址方式**

操作数包含在指令中的寻址方式是立即寻址（最快）；操作数在寄存器中的寻址方式是寄存器寻址；操作数的地址包含在指令中是直接寻址；操作数的地址存放在寄存器中的寻址方式是寄存器间接寻址。

**原码、反码、补码及移码**

计算机中的信息都是以二进制形式表示的，数值有正负之分，计算机就用一个数的最高位存放符号(0为正，1为负)。这就是机器数的原码了。

有了数值的表示方法就可以对数进行算术运算。但是很快就发现用带符号位的原码进行乘除运算时结果正确，而在加减运算的时候就出现了问题。因为在两个整数的加法运算中是没有问题的，于是就发现问题出现在带符号位的负数身上，对除符号位外的其余各位逐位取反就产生了反码。反码解决了负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则。

在人们的计算概念中零是没有正负之分的，于是就引入了补码概念。负数的补码就是对反码加一，而正数不变，正数的原码反码补码是一样的。移码解决了负数加法运算正负零问题，弥补了反码的不足。

移码常用来比较大小，一般会把浮点数的阶码用移码表示，说的再通俗一点，你把数值用移码表示出来可以一眼看出他们的大小。这样很容易判断阶码的大小，移码可用于简化浮点数的乘除法运算。

正数的原码、补码、反码均为其本身；负数（二进制）的原码、补码、反码公式：反码 = 原码（除符号位外）每位取反、补码 = 反码 + 1、反码 = 补码  - 1、移码 = 补码符号位取反。

**CPU寄存器**

CPU中通常设置一些寄存器，用于暂时存储程序运行过程中的相关信息。其中，通用寄存器常用于暂存运算器需要的数据或运算结果，地址寄存器和数据寄存器用于访问内存时的地址和数据暂存，指令寄存器用于暂存正在执行的指令，程序计数器中存放待执行的指令的地址。

**媒体**

媒体分为感觉媒体、表示媒体、表现媒体、存储媒体和传输媒体 

- 感觉媒体：能直接作用于人们的感觉器官，从而能使人产生直接感觉的媒体。如文字、数据、声音、图形、图像等。 在多媒体计算机技术中，我们所说的媒体一般指的是感觉媒体。 
- 表示媒体：为了传输感觉媒体而人为研究出来的媒体。如语言编码、电报码、条形码等。 
- 表现媒体：用于通信中使电信号和感觉媒体之间产生转换用的媒体。如输入、输出设备，包括键盘、鼠标器、显示器、打印机等。 
- 存储媒体：用于存放表示媒体的媒体。如纸张、磁带、磁盘、光盘等。

#### 软件工程与UML

**软件能力成熟度模型**

软件能力成熟度模型将软件过程的成熟度分为5个等级,以下是5个等级的基本特征：

1. 初始级：工作无序，项目进行过程中常放弃当初的计划。管理无章法，缺乏健全的管理制度。开发项目成效不稳定，项目成功主要依靠项目负责人的经验和能力，他一但离去，工作秩序面目全非。
2. 可重复级：管理制度化，建立了基本的管理制度和规程，管理工作有章可循。 
3. 已定义级：开发过程，包括技术工作和管理工作，均已实现标准化、文档化。
4. 已管理级：产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的。
5. 优化级：可集中精力改进过程，采用新技术、新方法。拥有防止出现缺陷、识别薄弱环节以及加以改进的手段。

**软件概要设计方法**

1. 以数据流图为基础构造模块结构的结构化设计方法；
2. 以数据结构为基础构造模块的Jackson方法；
3. 以类、对象、继承和通信为基础的面向对象设计方法。

**UML**

UML是数据库设计过程中，在E-R图（实体-联系图）的设计后的进一步建模。要了解一下UML设计中有的图例及基本作用。首先对UML中的各个图的功用做一个简单介绍：

- 用例图：描述角色以及角色与用例之间的连接关系。说明的是谁要使用系统，以及他们使用该系统可以做些什么。在统一过程中，用例图是通过捕获需求得到的。

  > UML用例图设计中用例之间关系：关联关系（参与者与用例只有关联关系）、聚合关系（关联关系的一种特例。聚合是整体和个体之间的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享）、组合（合成）关系（也是关联关系的一种特例，他体现的是一种contains-a的关系；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束）、包含关系（Include）、扩展关系（Extend）以及泛化关系。


- 类图：类图是描述系统中的类，以及各个类之间的关系的静态视图。

  > 在UML类图中，常见的有以下几种关系：泛化（继承关系, 表示一般与特殊的关系, 它指定了子类如何特化父类的所有特征和行为），实现，关联（拥有的关系, 它使一个类知道另一个类的属性和方法）， 聚合，组合以及依赖。 各种关系的强弱顺序：泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖。

- 对象图：类图的实例，对象图显示类的多个对象实例，而不是实际的类。

- 包图：包图用于描述系统的分层结构，由包或类组成，表示包与包之间的关系。

- 活动图：描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。

- 状态图：描述类的对象所有可能的状态，以及事件发生时状态的转移条件。状态图是对类图的补充。

- 序列图：用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。

- 协作图：和序列图相似，显示对象间的动态合作关系。

- 构件图：描述代码构件的物理结构以及各种构建之间的依赖关系。

- 部署图：是用来建模系统的物理部署。例如计算机和设备，以及它们之间是如何连接的。

**鲁棒图元素**

鲁棒图包含3种元素，它们分别是边界对象、控制对象、实体对象：

- 边界对象：对模拟外部环境和未来系统之间的交互进行建模。边界对象负责接收外部输入，处理内部内容的解释，并表达或传递相应的结果。
- 控制对象：对行为进行封装，描述用例中事件流的控制行为。
- 实体对象：对信息进行描述，它往往来自领域概念，和领域模型中的对象有良好的对应关系。

**风险管理**

风险管理包括了风险识别、风险预测、风险评估以及风险管理与监控4个活动。

1. 风险识别：建立风险条目检查表
2. 风险预测：评价风险发生的可能性以及风险发生所产生的后果
3. 风险评估：定义风险参照水准
4. 风险管理与监控（风险控制）：风险避免（对付风险的最好方法）、风险监控和风险管理及意外事件计划是需要考虑的问题。

**软件维护**

软件维护一般分为以下4种：

1. 更正性维护（正确性维护）。由于系统测试不可能揭露系统存在的所有错误，因此在系统投入运行后频繁的实际应用过程中，就有可能暴露出系统内隐藏的错误。诊断和修正系统中遗留的错误，就是纠错性维护。纠错性维护时在系统运行中发生异常或故障时进行的。（所占比重最大）
2. 适应性维护。适应性维护时为了使系统适应环境的变化而进行的维护工作。
3. 完善性维护。在系统的使用过程中，用户往往要求扩充原有系统的功能，增加一些在软件需求规范书中没有规定的功能与性能特征，以及对处理效率和编写程序的改进。
4. 预防性维护。系统维护工作不应总是被动地等待用户提出要求后才进行，应进行主动的预防性维护，即选择那些还有较长使用寿命，目前尚能正常运行，但可能将要发生变化或调整的系统进行维护，目的是通过预防性维护为未来的修改与调整奠定更好的基础。

**软件测试**

从软件开发的过程按阶段划分有单元测试、集成测试、确认测试（检查已实现的软件是否满足了需求规格说明中确定了的各种需求，以及软件配置是否完全、正确）、系统测试（把已确认的软件纳入实际运行环境中，与其它系统成份组合在一起进行测试）、验收测试、回归测试、Alpha测试以及Beta测试

白盒测试包括以下几种方式：

- 语句覆盖（最弱）：被测程序的每一个语句至少执行一次；
- 判定覆盖：每个判定的所有可能结果至少出现一次； 
- 条件覆盖：判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支；
- 路径覆盖（较强）：是每条可能执行到的路径至少执行一次。

不论那种覆盖方法，都不能保证程序的正确性。 

#### 操作系统

**PV操作**

P（S）：① 将信号量S的值减1，即S=S-1；② 如果S≥0，则该进程继续执行；否则该进程状态置为阻塞状态，进程PCB排入信号量PCB队列末尾，放弃CPU，等待V操作的执行。

V（S）：① 将信号量S的值加1，即S=S+1；② 如果S≤0，释放信号量队列中第一个PCB所对应的进程，将进程状态由阻塞态改为就绪态。执行V操作的进程继续执行。

一般来说，信号量S≥0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S小于等于0，表示有某些进程正在等待该资源，因此要唤醒一个阻塞状态的进程，使之成为就绪状态。

**虚拟设备**

在操作系统中，虚拟设备通常采用Spooling技术，利用磁盘来提供虚拟设备。

#### 数据结构与算法

**中缀表达式、前缀表达式及后缀表达式**

前缀表达式：运算符位于操作数之前。从右往左扫描计算。
后缀表达式：运算符位于操作数之后。从左往右扫描计算。
后缀表达式与前缀表达式类似，只是运算符位于操作数之后。

#### 数据库

**数据库基础**

数据库四特征（ACID）（原子性、一致性、隔离性、持久性）。

数据库可能产生不一致的原因：数据冗余、并发控制不当、故障和错误

数据库系统的安全措施主要有权限机制、视图机制以及数据加密三个方面。

**数据库操作**

- 数据查询：SELECT
- 数据操纵：UPDATE,INSERT,DELETE
- 数据定义：CREATE,DROP
- 数据控制：COMMIT,ROLLBACK,GRANT等

**数据库规范**

- 第一范式（1NF）：属性不可分。
- 第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码。
- 第三范式（3NF）：符合2NF，并且，消除传递依赖。
- BC范式（BCNF）：符合3NF，并且，每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。

- 第四范式：要求把同一表内的多对多关系删除。


#### 计算机网络

**计算机网络基础**

使用路由器或三层交换机能够实现在不同子网间隔离广播风暴的作用。

实现VPN的关键技术主要有隧道技术、加解密技术、密钥管理技术和身份认证技术。L2TP、PPTP是两种链路层的VPN协议，TLS是传输层VPN协议，IPsec是网络层VPN协议。 

**应用层协议**

- DNS（UDP ，端口53）
- TFTP（UDP，端口69）
- RIP（UDP）
- DHCP（UDP，端口67）
- SNMP（UDP）
- NFS（UDP）
- IGMP（UDP）
- SMTP（TCP，端口25）
- TELNET（TCP，端口23）
- HTTP（TCP，端口80）
- FTP（TCP，连接端口21、数据端口20）
- POP3（端口110）

#### 编译原理

**4种文法**

文法G的定义：四元组(Vn，Vt，P，S) 。Vn：是非终结符集；Vt：终结符集；P：表示一种规则（a->b）ab表示终结符和非终结符的集合，但a中至少包括一个非终结符。Vn，Vt，P是非空有穷集合。S：表示开始符，他是一个非终结符，至少要有一条规则在左侧。

0型文法的能力相当于图灵机。0型文法形式文法分类中泛指任何文法。1型文法是0型文法的子类，2型文法是1型文法的子类，3型文法是2型文法的子类。

1型文法（上下文有关文法）是在0型文法的基础上每一个α→β,都有\|β\|>=\|α\|。这里的\|β\|表示的是β的长度。1型文法相当于线性有界自动机。如有A->Ba则\|β\|=2,\|α\|=1符合1型文法要求。反之,如aA->a，则不符合1型文法。α→ε也满足1型文法。

2型文法（上下文无关文法）是在1型文法的基础上再满足：每一个α→β都有α是一个非终结符。如A->Ba，符合2型文法要求。2型文法相当于下推自动机。例子：Ab->Bab虽然符合1型文法要求，但不符合2型文法要求，因为其α=Ab，而Ab不是一个非终结符。

3型文法（正规文法）是在2型文法的基础上满足：A→α\|αB（右线性）或A→α\|Bα（左线性）。3型文法相当于有限状态自动机。3型文法中只能满足右线性，或只能满足左线性，不能两种同时都有。如有：A->a,A->aB,B->a,B->cB，则符合3型文法的要求。但如果推导为：A->ab,A->aB,B->a,B->cB或推导为：A->a,A->Ba,B->a,B->cB则不符合3型方法的要求了。具体的说，例子A->ab,A->aB,B->a,B->cB中的A->ab不符合3型文法的定义，如果把后面的ab，改成“一个非终结符＋一个终结符”的形式（即为aB）就对了。例子A->a,A->Ba,B->a,B->cB中如果把B->cB改为B->Bc的形式就对了，因为A→α\|αB（右线性）和A→α\|Bα（左线性）两套规则不能同时出现在一个语法中，只能完全满足其中的一个，才能算3型文法。

**最左推导和最右推导**

最左推导：每一步替换最左边的非终结符

最右推导：每一步替换最右边的非终结符，最右推导称为规范推导。

例：

S--->AB

A--->a|t

B---->+CD

C--->a

D---->a

最右推导：

S--->AB---->A+CD--->A+Ca---->A+aa----->a+aa

最左推导：

S---->AB----->aB--->a+CD--->a+aD----->a+aa

**中间代码**

中间代码的表达形式有语法树，后缀式，三地址代码。

## 后记

由于每个人的情况不一样，所以这里的笔记只针对本人薄弱的地方，所以不建议大家参考，但是如果大家喜欢这种复习方式的话，可以选择借鉴。

软考终于告一段落，接下来要把精力分配在课内学习、项目、比赛以及考研准备上。笔者也深信，这一次的复习所带来的收获会为后面的考研及开发学习带来极大的帮助。