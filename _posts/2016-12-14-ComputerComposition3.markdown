---
layout:     post
title:      "走进计算机组成原理（三）"
subtitle:   "中央处理器"
date:       2016-12-14 18:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 计算机组成原理
---

> 计算机组成原理第三站


## 前言

之前都是把CPU看做一个“黑匣子”进行分析，本文我们就来剖析一下它的内部结构，讲述CPU的功能。

---

## 正文

#### 计算机的运算方法

**计算机中数的表示**

- *无符号数和有符号数*

  无符号数与有符号数的数值范围是不同的，以机器字长为16位为例，无符号数的表示范围为0\~65535，有符号数的表示范围为-32768\~+32767（此数值对应补码表示）。

  计算机中的信息都是以二进制形式表示的，主要是因为**物理器件性能所致**。数值有正负之分，计算机就用一个数的最高位存放符号(0为正，1为负)。这就是机器数的原码了。

  有了数值的表示方法就可以对数进行算术运算。但是很快就发现用带符号位的原码进行乘除运算时结果正确，而在加减运算的时候就出现了问题。因为在两个整数的加法运算中是没有问题的，于是就发现问题出现在带符号位的负数身上，对除符号位外的其余各位逐位取反就产生了反码。反码解决了负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则。

  在人们的计算概念中零是没有正负之分的，于是就引入了补码概念。负数的补码就是对反码加一，而正数不变，正数的原码反码补码是一样的。移码解决了负数加法运算正负零问题，弥补了反码的不足。

  移码常用来比较大小，一般会把浮点数的阶码用移码表示，说的再通俗一点，你把数值用移码表示出来可以一眼看出他们的大小。这样很容易判断阶码的大小，移码可用于简化浮点数的乘除法运算。对于移码，0的形式是唯一的。

  正数的原码、补码、反码均为其本身；负数（二进制）的原码、补码、反码公式：反码 = 原码（除符号位外）每位取反、补码 = 反码 + 1、反码 = 补码  - 1、**移码 = 补码符号位取反**。

- *数的定点表示和浮点表示*

  小数点固定在某一位置的数为定点数，小数点位置变化的数叫浮点数。浮点数在数的表示范围、数的精度、溢出处理和程序编程方面均优于定点数。

  在整数定点机中，三种机器数均可表示-1，而在小数定点机中，只有补码能表示-1。

  浮点数由阶码 j 和尾数 S 两部分组成。阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围和小数点的实际位置；尾数是小数，其位数n反映了浮点数的精度，尾数的符号代表浮点数的正负。

  浮点数的规格化形式与机器数有关，不同的机器数有不同的规格化形式，原码规格化后尾数的第一数位为1，而补码规格化后尾数的符号位与第一数位不同。采用规格化的浮点数主要是为了**增加数据的表示精度**

  > **例题1**
  >
  > [X]补=1.0000000，它代表的真值是（  B  ）
  >
  > A.  -0          B.  -1         C.  +1          D.  无具体意义
  >
  > **例题2**
  >
  > 设x为整数，[x]补=1，x1x2x3x4x5，若按x＜-16，则____。
  >
  > A．x1=1，x2～x5任意
  >
  > B．x1=0，x2～x5至少有一个为1
  >
  > C．x1=0，x2～x5任意
  >
  > D．x1=1，x2～x5至少有一个为1
  >
  > 前面的1是表示的是负数
  >
  > 欲求-16，先求16的原码为10000，其反码为01111，则补码为10000，添上符号位就成了110000，这就是-16的补码。
  >
  > 下来求-17，17的原码10001，取反 01110 在加1 为01111，添上符号位为101111，以此类推，由此得出，要小于-16，x1必须为0，x2-x5任意。

**定点运算**

- *移位运算*

  移位运算包括算术移位和逻辑移位。有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。

  算术移位后的空位添补规则为：正数原码、补码和反码都添0，负数原码添0，负数补码左移添0，右移添1，负数反码添1。

- *加法与减法运算*

  加减法运算时最基本的运算，减法运算可以看成特殊的加法运算，对于两个数进行加法运算，首先把它们化成补码形式，然后进行运算，运算后的结果按2的n+1次方取模（对于整数）或按2取模（对于小数），则可以得到和的补码形式。

  定点加减运算出现溢出时，则运算结果是错误的，有两种方法判断溢出。一种是用一位符号位判断溢出，对于加法，只有在同符号数相加时才可能出现溢出，如果结果与原操作数的符号不同，则称为溢出。另一种是用双符号位判断溢出，这种方法用于变形补码，若运算结果的两个符号位相同，则表示未溢出，反之则表示溢出。

- *乘法运算和除法运算*

  在计算机中，有的机器由硬件乘法器直接完成乘法的计算，有的机器没有乘法器，但可以按机器做乘法运算的方法，用软件编程实现。乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。

  原码一位乘的运算规则如下：a.乘积的符号位由两原码符号位异或运算结果决定；b.乘积的数值部分由两数绝对值相乘。原码两位乘可以提高乘法速度，它与原码一位乘一样，符号位的运算和数值部分都是分开进行的，符号位单独处理，参与操作的数是**绝对值的补码**。

  原码除法有两种方法，即恢复余数法和不恢复余数法（加减交替法），前者的特点是：当余数为负时，需加上除数，将其恢复成原来的余数，后者则是最后一次余数为负时，要恢复一次余数。在原码加减交替除法中，符号位单独处理，参与操作的数是绝对值的补码。在补码加减交替除法中，参与操作的数是补码，商符在形成商值的过程中自动形成。

**浮点运算**

浮点加减运算一律采用补码，浮点乘除运算的阶码采用补码或移码，尾数采用补码或原码。

两个浮点规格化数相乘，不可能右规，可能左规，且左规次数为1。

浮点数的舍入处理方法主要是0舍1入法和恒置1法，前者跟十进制的四舍五入方法几乎相同，后者则无论舍去的数值是多少，都在右移后的尾数末位恒置1，如果原先为1，则无需操作。

#### 指令系统



## 后记


