---
layout:     post
title:      "走进计算机组成原理（三）"
subtitle:   "中央处理器"
date:       2016-12-14 18:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 计算机组成原理
---

> 计算机组成原理第三站


## 前言

之前都是把CPU看做一个“黑匣子”进行分析，本文我们就来剖析一下它的内部结构，讲述CPU的功能。

---

## 正文

#### 计算机的运算方法

**计算机中数的表示**

- *无符号数和有符号数*

  无符号数与有符号数的数值范围是不同的，以机器字长为16位为例，无符号数的表示范围为0\~65535，有符号数的表示范围为-32768\~+32767（此数值对应补码表示）。

  计算机中的信息都是以二进制形式表示的，主要是因为**物理器件性能所致**。数值有正负之分，计算机就用一个数的最高位存放符号(0为正，1为负)。这就是机器数的原码了。

  有了数值的表示方法就可以对数进行算术运算。但是很快就发现用带符号位的原码进行乘除运算时结果正确，而在加减运算的时候就出现了问题。因为在两个整数的加法运算中是没有问题的，于是就发现问题出现在带符号位的负数身上，对除符号位外的其余各位逐位取反就产生了反码。反码解决了负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则。

  在人们的计算概念中零是没有正负之分的，于是就引入了补码概念。负数的补码就是对反码加一，而正数不变，正数的原码反码补码是一样的。移码解决了负数加法运算正负零问题，弥补了反码的不足。

  移码常用来比较大小，一般会把浮点数的阶码用移码表示，说的再通俗一点，你把数值用移码表示出来可以一眼看出他们的大小。这样很容易判断阶码的大小，移码可用于简化浮点数的乘除法运算。对于移码，0的形式是唯一的。

  正数的原码、补码、反码均为其本身；负数（二进制）的原码、补码、反码公式：反码 = 原码（除符号位外）每位取反、补码 = 反码 + 1、反码 = 补码  - 1、**移码 = 补码符号位取反**。

- *数的定点表示和浮点表示*

  小数点固定在某一位置的数为定点数，小数点位置变化的数叫浮点数。浮点数在数的表示范围、数的精度、溢出处理和程序编程方面均优于定点数。

  在整数定点机中，三种机器数均可表示-1，而在小数定点机中，只有补码能表示-1。

  浮点数由阶码 j 和尾数 S 两部分组成。阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围和小数点的实际位置；尾数是小数，其位数n反映了浮点数的精度，尾数的符号代表浮点数的正负。

  浮点数的规格化形式与机器数有关，不同的机器数有不同的规格化形式，原码规格化后尾数的第一数位为1，而补码规格化后尾数的符号位与第一数位不同。采用规格化的浮点数主要是为了**增加数据的表示精度**

  > **例题1**
  >
  > [X]补=1.0000000，它代表的真值是（  B  ）
  >
  > A.  -0          B.  -1         C.  +1          D.  无具体意义
  >
  > **例题2**
  >
  > 设x为整数，[x]补=1，x1x2x3x4x5，若按x＜-16，则____。
  >
  > A．x1=1，x2～x5任意
  >
  > B．x1=0，x2～x5至少有一个为1
  >
  > C．x1=0，x2～x5任意
  >
  > D．x1=1，x2～x5至少有一个为1
  >
  > 前面的1是表示的是负数
  >
  > 欲求-16，先求16的原码为10000，其反码为01111，则补码为10000，添上符号位就成了110000，这就是-16的补码。
  >
  > 下来求-17，17的原码10001，取反 01110 在加1 为01111，添上符号位为101111，以此类推，由此得出，要小于-16，x1必须为0，x2-x5任意。

**定点运算**

- *移位运算*

  移位运算包括算术移位和逻辑移位。有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。

  算术移位后的空位添补规则为：正数原码、补码和反码都添0，负数原码添0，负数补码左移添0，右移添1，负数反码添1。

- *加法与减法运算*

  加减法运算时最基本的运算，减法运算可以看成特殊的加法运算，对于两个数进行加法运算，首先把它们化成补码形式，然后进行运算，运算后的结果按2的n+1次方取模（对于整数）或按2取模（对于小数），则可以得到和的补码形式。

  定点加减运算出现溢出时，则运算结果是错误的，有两种方法判断溢出。一种是用一位符号位判断溢出，对于加法，只有在同符号数相加时才可能出现溢出，如果结果与原操作数的符号不同，则称为溢出。另一种是用双符号位判断溢出，这种方法用于变形补码，若运算结果的两个符号位相同，则表示未溢出，反之则表示溢出。

- *乘法运算和除法运算*

  在计算机中，有的机器由硬件乘法器直接完成乘法的计算，有的机器没有乘法器，但可以按机器做乘法运算的方法，用软件编程实现。乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。

  原码一位乘的运算规则如下：a.乘积的符号位由两原码符号位异或运算结果决定；b.乘积的数值部分由两数绝对值相乘。原码两位乘可以提高乘法速度，它与原码一位乘一样，符号位的运算和数值部分都是分开进行的，符号位单独处理，参与操作的数是**绝对值的补码**。

  原码除法有两种方法，即恢复余数法和不恢复余数法（加减交替法），前者的特点是：当余数为负时，需加上除数，将其恢复成原来的余数，后者则是最后一次余数为负时，要恢复一次余数。在原码加减交替除法中，符号位单独处理，参与操作的数是绝对值的补码。在补码加减交替除法中，参与操作的数是补码，商符在形成商值的过程中自动形成。

**浮点运算**

浮点加减运算一律采用补码，浮点乘除运算的阶码采用补码或移码，尾数采用补码或原码。

两个浮点规格化数相乘，不可能右规，可能左规，且左规次数为1。

浮点数的舍入处理方法主要是0舍1入法和恒置1法，前者跟十进制的四舍五入方法几乎相同，后者则无论舍去的数值是多少，都在右移后的尾数末位恒置1，如果原先为1，则无需操作。

#### 指令系统

**地址码形式**

从计算机诞生至今，指令的地址码字段经历了四地址、三地址、二地址、一地址和零地址这几个阶段。

零地址运算指令在指令格式中不给出操作数地址。它的操作数来自**栈顶和次栈顶**。

一地址指令中，为完成两个数的算术运算，除地址译码指明的一个操作数外，另一个数常采用**隐含寻址方式**。通常一地址格式的算术运算指令，另一个操作数隐含在**累加器**中。一地址指令是**固定长度**的指令。对于一地址，可能有一个操作数，也可能有两个操作数。

二地址指令中，操作数的物理位置可以在寄存器，也可以在内存。运算结果通常存放在其中一个地址码所提供的地址中。

**寻址方式**

- *指令寻址*

  指令系统中采用不同寻址方式的目的主要是**缩短指令字长，扩大寻址空间，提高编程灵活性**。指令寻址分顺序寻址和跳跃寻址。顺序寻址可通过程序计数器PC加1，自动形成下一条指令的地址；跳跃寻址则通过转移类指令来实现，可以实现**程序的条件转移和无条件转移**。


- *数据寻址*

  数据寻址方式众多，主要有以下几种：

  立即寻址：形式地址A就是操作数本身，称作立即数（补码表示），指令在执行阶段不访存。

  直接寻址：直接寻址EA=A，有效地址EA由形式地址A直接给出，指令在执行阶段访问一次存储器。

  隐含寻址：操作数隐含在操作码中，可缩短指令字长。

  间接寻址：间接寻址EA=(A)，有效地址EA由形式地址A间接提供，指令在执行阶段要多次访存，一次间址需两次访存，多次间址需根据存储字的最高位确定几次访存，可扩大寻址范围。

  寄存器寻址：操作数在寄存器中的寻址方式，指令在执行阶段不访存，只访问寄存器，执行速度快。为了**缩短指令中地址码的位数**，应采用寄存器寻址。

  寄存器间接寻址：有效地址EA在寄存器中，操作数在**主存单位**中，所以指令的执行阶段需要访存。寄存器间址便于编制循环程序。

  基址寻址：操作数的有效地址是**基址寄存器内容加上形式地址（位移量）**，基址寄存器的内容由操作系统或管理程序确定，在程序执行过程中不可变。基址寻址可以扩大寻址范围。

  变址寻址：操作数的有效地址是**变址寄存器内容加上形式地址**，变址寄存器内容由用户决定，在程序执行过程中可变。变址寻址同样可以扩大寻址范围。变址寻址便于处理数组问题。

  相对寻址：相对寻址EA=(PC)+A，A是相对于当前指令地址的位移量，可正可负，补码表示。相对寻址对于实现程序浮动提供了较好的支持。

  堆栈寻址：多个寄存器可构成硬堆栈，指定的存储空间可构成软堆栈，其特点是先进后出。堆栈的栈顶地址由SP指出，堆栈寻址的有效地址EA隐含在堆栈指针SP中。每次进栈或出栈，SP自动修改。如进栈(SP)-1->SP，出栈(SP)+1->SP。

#### CPU的结构和功能

- 指令周期是指CPU从主存中取出一条指令加上执行这条指令的时间，指令周期大于机器周期。

## 后记

这一部分内容比较多，其中第一部分《计算机的运算方法》极其重要。下一篇文章将会对控制单位进行讲解，这也是这个计算机组成原理部分的最后一块内容。
