---
layout:     post
title:      "设计模式之迭代器模式"
subtitle:   "当设计模式遇见集合"
date:       2017-05-10 20:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 设计模式
---

> 一种新的遍历集合的方法
>


## 前言

或许你对Java集合机制中的迭代器已经非常熟悉了，那么这篇关于迭代器模式讲解的文章一定能让你的理解更深入一步！

---

## 正文

**什么是迭代器模式**

迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示，它包括以下角色：

- Iterator：迭代器。定义遍历元素所需接口
- ConcreteIterator：具体迭代器。实现了Iterator接口，并保持迭代过程中的游标位置
- Aggregate：聚合。此抽象角色给出创建迭代器对象的接口
- ConcreteAggregate：具体聚合。实现了创建迭代器对象的接口，返回一个合适的具体迭代器实例

**怎么使用迭代器模式**

***步骤一：创建Iterator***

```java
package com.iterator;

public interface Iterator {
	
	public void first();

	public void next();

	public boolean isDone();

	public Object currentItem();
	
}
```

***步骤二：创建Aggregate***

```java
package com.iterator;

public abstract class Aggregate {
    public abstract Iterator createIterator();
}
```

***步骤三：创建ConcreteAggregate***

```java
package com.iterator;

public class ConcreteAggregate extends Aggregate {

	private Object[] objArray = null;

	public ConcreteAggregate(Object[] objArray) {
		this.objArray = objArray;
	}

	@Override
	public Iterator createIterator() {

		return new ConcreteIterator(this);
	}

	public Object getElement(int index) {

		if (index < objArray.length) {
			return objArray[index];
		} else {
			return null;
		}
	}

	public int size() {
		return objArray.length;
	}

}
```

***步骤四：创建ConcreteIterator***

```java
package com.iterator;

public class ConcreteIterator implements Iterator {

	private ConcreteAggregate agg;
	private int index = 0;
	private int size = 0;

	public ConcreteIterator(ConcreteAggregate agg) {
		this.agg = agg;
		this.size = agg.size();
		index = 0;
	}

	@Override
	public Object currentItem() {
		return agg.getElement(index);
	}

	@Override
	public void first() {
		index = 0;
	}

	@Override
	public boolean isDone() {
		return (index >= size);
	}

	@Override
	public void next() {
		if (index < size) {
			index++;
		}
	}

}
```

***步骤五：创建Client***

```java
package com.iterator;

public class Client {

	public void operation() {
		Object[] objArray = { "One", "Two", "Three", "Four", "Five", "Six" };
		Aggregate agg = new ConcreteAggregate(objArray);
		Iterator it = agg.createIterator();
		while (!it.isDone()) {
			System.out.println(it.currentItem());
			it.next();
		}
	}

	public static void main(String[] args) {
		Client client = new Client();
		client.operation();
	}

}
```

**迭代器模式有哪些优缺点**

***优点***

- 支持以不同方式遍历聚合对象
- 简化了聚合类
- 在同一聚合上可以有多个遍历
- 在迭代器模式中，增加新的聚合类和迭代器类很方便，无须修改原有代码

***缺点***

- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需增加新的迭代器类，类的个数成对增加，一定程度增加了系统复杂性



**迭代器模式适用于什么环境**

- 访问聚合对象的内容而无须暴露它的内部表示
- 需要为聚合对象提供多种遍历方式
- 为遍历不同聚合结构提供统一接口


## 后记

也许对于早已熟悉迭代器的你来说，这篇文章的内容早已经熟知了，但无论如何，希望这篇文章能够给你带来一定帮助。
