---
layout:     post
title:      "《背包九讲》笔记（二）"
subtitle:   "完全背包问题"
date:       2017-08-22 21:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 数据结构与算法
---

> 升级了的背包问题
>

## 前言

完全背包问题是01背包问题的升级版，它的主要改变是在物品的数量从1变成了多个。

---

## 正文

**题目**

有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的耗费空间是 Ci ，价值是 Wi 。求将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大

**题目分析**

按照上一篇文章对01背包问题的解析，我们可以得到状态转移方程：`F[i, v] = max{F[i − 1, v − kCi] + kWi | 0 ≤ kCi ≤ v}`。但是这个状态转移方程的时间复杂度达到三个维度，所以我们必须进行一定的优化。

**实现代码**

程序一：

```c

```
程序二：

```c

```

程序三：

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<limits.h>

int n, v;
int *c, *w;
int *f;

int main() {
    while(scanf("%d%d", &n, &v) == 2) {
        c = (int *)malloc(sizeof(int) * (n + 1));
        w = (int *)malloc(sizeof(int) * (n + 1));
        f = (int *)malloc(sizeof(int) * (v + 1));
        f[0] = 0;
        for(int i = 1; i <= v; i++) {
            f[i] = INT_MIN;
        }
        for(int i = 1; i <= n; i++) {
            scanf("%d%d", &c[i], &w[i]);
        }
        for(int i = 1; i <= n; i++) {
            for(int j = v; j >= c[i]; j--) {
                f[j] = f[j] > f[j - c[i]] + w[i] ? f[j] : f[j - c[i]] + w[i];
            }
        }
        printf("%d\n", f[v]);
    }
    return 0;
}
```

## 后记

01背包问题虽然简单，但却为我们后面几个背包问题的学习打下了良好的基础，所以我们必须牢固掌握。
