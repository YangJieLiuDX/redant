---
layout:     post
title:      "设计模式之观察者模式"
subtitle:   "设计模式里的超级模式"
date:       2017-06-01 16:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 设计模式
---

> 下蛋公鸡，公鸡里的战斗鸡
>


## 前言

观察者模式是设计模式里面的超级模式，在实际编程中运用广泛，今天就让我们一起来学习一下它！

---

## 正文

**什么是观察者模式**

当对象间存在一对多关系时，则使用观察者模式。如当一个对象被修改时，则会自动通知它的依赖对象。它主要包括以下角色：

- 被观察者：包含一个用来存放观察者对象的Vector容器（被观察者类的核心）和attach方法（向容器中添加观察者对象）、detach方法（从容器中移除观察者对象）、notify方法（依次调用观察者对象的对应方法）等三个方法
- 观察者：一般是一个接口，只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用
- 具体的被观察者：定义具体的业务逻辑
- 具体的观察者：观察者接口的具体实现，定义被观察者对象状态发生变化时所要处理的逻辑

**怎么使用观察者模式**

***步骤一：创建Subject***

```java
package com.observer;

import java.util.Vector;

public abstract class Subject {
	private Vector<Observer> obs = new Vector<Observer>();

	public void addObserver(Observer obs) {
		this.obs.add(obs);
	}

	public void delObserver(Observer obs) {
		this.obs.remove(obs);
	}

	protected void notifyObserver() {
		for (Observer o : obs) {
			o.update();
		}
	}

	public abstract void doSomething();
}
```

***步骤二：创建Observer***

```java
package com.observer;

public interface Observer {
	public void update();
}
```

***步骤三：创建ConcreteSubject***

```java
package com.observer;

public class ConcreteSubject extends Subject {
    public void doSomething(){
        System.out.println("被观察者事件发生");
        this.notifyObserver();
    }
}
```

***步骤四：创建ConcreteObserver***

ConcreteObserver1类：

```java
package com.observer;

public class ConcreteObserver1 implements Observer {
    public void update() {
        System.out.println("观察者1收到信息，并进行处理。");
    }
}
```

ConcreteObserver2类：

```java
package com.observer;

public class ConcreteObserver2 implements Observer {
	public void update() {
		System.out.println("观察者2收到信息，并进行处理。");
	}
}
```

***步骤五：创建Client***

```java
package com.observer;

public class Client {
	public static void main(String[] args) {
		Subject sub = new ConcreteSubject();
		sub.addObserver(new ConcreteObserver1());
		sub.addObserver(new ConcreteObserver2());
		sub.doSomething();
	}
}
```

**观察者模式有哪些优缺点**

***优点***

- 观察者和被观察者是抽象耦合的

- 建立一套触发机制


***缺点***

- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化


**观察者模式适用于什么环境**

- 有多个子类共有的方法，且逻辑相同

- 重要的、复杂的方法，可以考虑作为模板方法


## 后记

观察者模式是及其重要的模式之一，也希望读者们多花点心思在这上面。
