---
layout:     post
title:      "Tiny Web服务器源码学习"
subtitle:   "一个只有250行代码的Web服务器"
date:       2017-03-20 20:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - C
---

> 从最简单的学起


## 前言

Tiny Web服务器是《深入理解计算机系统》一书中11.6节的内容，该节演示了一个只有250行代码的服务器，非常适合对C语言和网络编程感兴趣的朋友进行学习！话不多说，让我们开始正式的学习！

---

## 正文

### 基本使用

Tiny Web服务器的主要代码在原书上已经给出，如果要下载完整的代码，可以在官网上进行下载，具体地址请点击[这里](http://csapp.cs.cmu.edu/3e/tiny.rar)，除此之外，在Github上也可以搜到热心用户上传的代码。

下载好代码之后，我们要进行编译才可以使用。如果是官网代码的话，直接使用`make`命令进行编译就可以了，如果不是的话（没有Makefile文件），则具体编译操作如下：

```shell
gcc tiny.c csapp.c -o tiny 
cd cgi-bin
gcc adder.c -o adder -I../
cd ..
```

编译完成后，我们只要执行`./tiny 8888`，就可以开启Tiny Web服务器了！

首先输入127.0.0.1:8888，可以对Tiny Web服务器的静态页面进行测试，然后输入127.0.0.1:8888/cgi-bin/adder?1&2，可以对服务器的动态页面进行测试。这里值得一提的是，Tiny Web服务器只支持GET请求，如果是POST请求的话，会返回错误信息。

### 源码解读

#### 套结字接口

套结字接口（socket interface）是一组函数，它们和Unix I/O函数结合起来，用以创建网络应用。学习socket编程能够让我们加深对网络框架的理解，socket编程的函数可以通过下图体现：

![套结字接口概述](http://images.cnitblog.com/blog/466768/201312/27113109-ad8f7a2ce6d64ae39706ef7db3aa07cd.png)

通过此图，我们可以大致了解socket包含哪些函数，接下来我们对几个重要的函数进行一一介绍：

**socket函数**

客户端和服务器使用socket函数来创建一个套接字描述符，具体使用如下：

```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```

其中，domain指定socket的通信协议集（AF_UNIX和AF_INET等），AF_UNIX只能用于单一的*nix系统，而AF_INET是用于网络的，所以可以允许远程主机之间的通信；type指定socket类型（SOCK_STREAM和SOCK_DGRAM等），SOCK_STREAM表明使用TCP协议，SOCK_DGRAM表明使用UDP协议；protocol指定实际使用的传输协议，如果该项为0，则使用缺省协议。调用socket函数后，成功会返回文件描述符，失败返回-1。

**bind函数**

bind函数是服务器特有的函数，其使用如下：

```c
#include <sys/socket.h>
int bind(int socket, const struct sockaddr *address, socklen_t address_len);
```

bind函数为socket分配地址，其中socket是套接字描述符，address指向sockaddr结构（用于表示所分配地址）的指针，address_len是sockaddr结构的长度。

**listen函数**

#include <sys/socket.h>
int listen(int socket, int backlog);
当 socket 和一个地址绑定后，调用 listen() 函数开始监听连接请求。但是，这只能在有可靠数据流保证时使用，如 SOCK_STREAM, SOCK_SEQPACKET 。
socket socket 的描述符
backlog 一个决定监听队列大小的整数，当有一个连接请求到来，就会进入此监听队列，当队列满后，新的连接请求会返回错误。
如果成功监听返回 0，否则返回 -1 。

**accept函数**

#include <sys/socket.h>
int accept(int socket, struct sockaddr *restrict address,
        socklen_t *restrict address_len);
当应用程序监听来自其他主机的面对数据流的连接时，通过事件（比如Unix select()系统调用）通知它。必须用 accept()函数初始化连接。 Accept() 为每个连接创立新的套接字并从监听队列中移除这个连接。它使用如下参数：
socket 监听的 socket 描述符
address 指向sockaddr 结构体的指针，客户机地址信息。
address_len 指向 socklen_t的指针，确定客户机地址结构体的大小 。
返回新的套接字描述符，出错返回-1。进一步的通信必须通过这个套接字。
Datagram 套接字不要求用accept()处理，因为接收方可能用监听套接字立即处理这个请求。

**connect函数**

#include <sys/socket.h>
int connect(int socket, const struct sockaddr *address,
        socklen_t address_len);
connect() 系统调用为一个套接字设置连接，参数有文件描述符和主机地址。
某些类型的套接字是无连接的，大多数是 UDP 协议。对于这些套接字，连接时这样的：默认发送和接收数据的主机由给定的地址确定，可以使用 send() 和 recv()。返回 -1 表示出错，0 表示成功。

#### tiny.c的main函数

**具体代码**

```c
int main(int argc, char **argv) 
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    /* Check command line args */
    if (argc != 2) {
	fprintf(stderr, "usage: %s <port>\n", argv[0]);
	exit(1);
    }

    listenfd = Open_listenfd(argv[1]);
    while (1) {
	clientlen = sizeof(clientaddr);
	connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen); //line:netp:tiny:accept
        Getnameinfo((SA *) &clientaddr, clientlen, hostname, MAXLINE, 
                    port, MAXLINE, 0);
        printf("Accepted connection from (%s, %s)\n", hostname, port);
	doit(connfd);                                             //line:netp:tiny:doit
	Close(connfd);                                            //line:netp:tiny:close
    }
}
```

**详细解析**

- main函数中的argc表示命令行参数的数目，argv表示参数列表。参数数目默认大于等于1，因为至少有一个参数，也就是argv[0]为程序名
- main函数定义完变量之后会判断传入参数是不是为2个，如果不是则输出错误信息并退出。这里需要的两个参数分别为程序名tiny和端口号。这里的fprintf函数的作用是格式化输出到流或文件中，其中第一个参数是文件指针，这里用的是stderr（Linux内核启动时默认打开三个I/O设备文件：标准输入文件stdin，标准输出文件stdout和标准错误输出文件stderr），后面两个参数分别是输出内容和参数列表
- 如果参数数目满足要求的话，就可以根据端口值创建监听描述符。这里的Open_listendfd（区分大小写）函数是属于csapp.c里面的函数，该函数封装了socket、bind和listen函数，具体内容我们后面再讲解
- 打开监听套接字后，服务器将会执行典型的无限服务器循环，不断地接受连接请求，执行事务，并关闭连接它的那一端

#### tiny.c的doit函数

**具体代码**

```c
/*
 * doit - handle one HTTP request/response transaction
 */
void doit(int fd) 
{
    int is_static;
    struct stat sbuf;
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char filename[MAXLINE], cgiargs[MAXLINE];
    rio_t rio;

    /* Read request line and headers */
    Rio_readinitb(&rio, fd);
    if (!Rio_readlineb(&rio, buf, MAXLINE))  //line:netp:doit:readrequest
        return;
    printf("%s", buf);
    sscanf(buf, "%s %s %s", method, uri, version);       //line:netp:doit:parserequest
    if (strcasecmp(method, "GET")) {                     //line:netp:doit:beginrequesterr
        clienterror(fd, method, "501", "Not Implemented",
                    "Tiny does not implement this method");
        return;
    }                                                    //line:netp:doit:endrequesterr
    read_requesthdrs(&rio);                              //line:netp:doit:readrequesthdrs

    /* Parse URI from GET request */
    is_static = parse_uri(uri, filename, cgiargs);       //line:netp:doit:staticcheck
    if (stat(filename, &sbuf) < 0) {                     //line:netp:doit:beginnotfound
	clienterror(fd, filename, "404", "Not found",
		    "Tiny couldn't find this file");
	return;
    }                                                    //line:netp:doit:endnotfound

    if (is_static) { /* Serve static content */
	if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR & sbuf.st_mode)) { //line:netp:doit:readable
	    clienterror(fd, filename, "403", "Forbidden",
			"Tiny couldn't read the file");
	    return;
	}
	serve_static(fd, filename, sbuf.st_size);        //line:netp:doit:servestatic
    }
    else { /* Serve dynamic content */
	if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR & sbuf.st_mode)) { //line:netp:doit:executable
	    clienterror(fd, filename, "403", "Forbidden",
			"Tiny couldn't run the CGI program");
	    return;
	}
	serve_dynamic(fd, filename, cgiargs);            //line:netp:doit:servedynamic
    }
}
```

**详细解析**

- 

## 后记


