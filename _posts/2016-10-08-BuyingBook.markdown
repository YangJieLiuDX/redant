---
layout:     post
title:      "《编程之美》之买书问题"
subtitle:   "做精明的买书者"
date:       2016-10-08 15:15:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 数据结构与算法
    - 编程之美
    - 贪心算法
    - 动态规划
---

> “一场动态规划战胜贪心算法的战斗”


## 前言

这个月开始啃之前买来的《编程之美》，并对其中一些问题进行实践和记录。

---

## 正文

#### 原题

> 上柜的《哈利波特》平装本系列，一共有五卷。假设每一卷单独销售均需8欧元。如果读者一次购买不同的两卷，就可以扣除5%的费用，三卷则更多。假设具体折扣的情况如下：
>
> - 种数2，折扣5%
> - 种数3，折扣10%
> - 种数4，折扣20%
> - 种数5，折扣25% 
>
> 问题：设计出算法，能够计算出读者所购买的一批书的最低价格。

#### 错误解法：

看到这种“简单”的题目，菜鸟博主忍不住一试，写了以下代码：

```c
#include <stdio.h>
#include <stdlib.h>

// 购买的种数
int n;
// 每一卷的数量
int *s;
// 保存折扣的数组
const float discount[5] = {0, 0.05, 0.1, 0.2, 0.25};

float getPrice() {
    // 当前种数
    int nn = n;
    // 当前价格
    float price = 0 ;
    while(1) {
        price += nn * 8 * (1 - discount[nn - 1]);
        for(int i = 0; i < n; i++) {
            if(s[i] != 0)
                s[i]--;
        }
        nn = n;
        for(int i = 0; i < n; i++) {
            if(s[i] == 0) {
                nn -= 1;
            }
        }
        if(nn == 0)
            break;
    }
    return price;
}

int main() {
    while(1) {
        scanf("%d", &n);
        s = malloc(sizeof(int) * n);
        for(int i = 0; i < n; i++) {
            scanf("%d", &s[i]);
        }
        printf("%.2f\n", getPrice());
    }
    return 0;
}
```

但是，当博主往后翻的时候，才发现自己做了个错误的示范。以上算法采用的是贪心策略，即每一步选择中都采取当前状态下最优选择（优先选择最大折扣），从而希望结果最优（价格最低）。可是原书用一个例子就否定了博主的这个算法

> 当买8本书，购买序列为（2,2,2,1,1）时：
>
> 选择5+3，即购买序列为（1,1,1,1,1）和（1,1,1,0,0），价格为51.6；
>
> 选择4+4，即购买序列为（1,1,1,1,0）和（1,1,1,0,1），价格为51.2。

因此我们也可以知道，在使用贪心算法前，**必须证明每一步最优能导致整体最优**。

#### 正确解法

原书在尝试改进贪心算法以谋求问题解决的方法上失败了，最后采取了动态规划法。

使用动态规划方法，最重要的一步是得到状态转移方程，原书推理过程较为复杂，这里直接给出最后得到的状态转移方程：

> F(Y1,Y2,Y3,Y4,Y5)
>
> = 0,                                                                                 if(Y1=Y2=Y3=Y4=Y5=0)
>
> = min {
>
> ​        5 * 8 * 0.75 + F(Y1-1,Y2-1,Y3-1,Y4-1,Y5-1),           if(Y5>=1)
>
> ​        4 * 8 * 0.8 + F(Y1-1,Y2-1,Y3-1,Y4-1,Y5),                if(Y4>=1)
>
> ​        3 * 8 * 0.9 + F(Y1-1,Y2-1,Y3-1,Y4,Y5),                   if(Y3>=1)
>
> ​        2 * 8 * 0.95 + F(Y1-1,Y2-1,Y3,Y4,Y5),                    if(Y2>=1)
>
> ​        8 + F(Y1-1,Y2,Y3,Y4,Y5)	                                        if(Y1>=1)
>
> } 

通过状态转移方程也可以看出解决这个问题所需要的空间复杂度和时间复杂度都为O(Y1 * Y2 * Y3 * Y4 * Y5)，所以本文就不给出相应的代码了。

## 后记

此文实验最主要目的并不是把最终的代码写出来，而是通过错误解法和正确解法的比较，能够对动态规划和贪心算法这两个在算法中经常遇到的解决方法有更深的理解。