---
layout:     post
title:      "《编程之美》之买书问题"
subtitle:   ""
date:       2016-10-08 15:15:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 算法
    - C
    - 编程之美
---

> “别想打我开发的app的主意”


## 前言

这个月开始啃之前买来的《编程之美》，并对其中一些问题进行实践和记录。

---

## 正文

#### 原题

> 上柜的《哈利波特》平装本系列，一共有五卷。假设每一卷单独销售均需8欧元。如果读者一次购买不同的两卷，就可以扣除5%的费用，三卷则更多。假设具体折扣的情况如下：
>
> - 种数2，折扣5%
> - 种数3，折扣10%
> - 种数4，折扣20%
> - 种数5，折扣25% 
>
> 问题：设计出算法，能够计算出读者所购买的一批书的最低价格。

#### 错误解法：

看到这种“简单”的题目，菜鸟博主忍不住一试，写了以下代码：

```c
#include <stdio.h>
#include <stdlib.h>

// 购买的种数
int n;
// 每一卷的数量
int *s;
// 保存折扣的数组
const float discount[5] = {0, 0.05, 0.1, 0.2, 0.25};

float getPrice() {
    // 当前种数
    int nn = n;
    // 当前价格
    float price = 0 ;
    while(1) {
        price += nn * 8 * (1 - discount[nn - 1]);
        for(int i = 0; i < n; i++) {
            if(s[i] != 0)
                s[i]--;
        }
        nn = n;
        for(int i = 0; i < n; i++) {
            if(s[i] == 0) {
                nn -= 1;
            }
        }
        if(nn == 0)
            break;
    }
    return price;
}

int main() {
    while(1) {
        scanf("%d", &n);
        s = malloc(sizeof(int) * n);
        for(int i = 0; i < n; i++) {
            scanf("%d", &s[i]);
        }
        printf("%.2f\n", getPrice());
    }
    return 0;
}
```

但是，当博主往后翻的时候，才发现自己做了个错误的示范。以上算法采用的是贪心策略，即每一步选择中都采取当前状态下最优选择（优先选择最大折扣），从而希望结果最优（价格最低）。可是原书用一个例子就否定了博主的这个算法

> 当买8本书，购买序列为（2,2,2,1,1）时：
>
> 选择5+3，即购买序列为（1,1,1,1,1）和（1,1,1,0,0），价格为51.6；
>
> 选择4+4，即购买序列为（1,1,1,1,0）和（1,1,1,0,1），价格为51.2。

因此我们也可以知道，在使用贪心算法前，**必须证明每一步最优能导致整体最优**。

## 后记

由于后面三种技术知识点比较深，所以此文没有作详细介绍，需要的朋友可以自行Google。

软件安全是计算机领域一个重要的版块，也希望通过这篇文章，让大家的开发安全意识有所提高。