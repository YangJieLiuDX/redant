---
layout:     post
title:      "《算法导论》之切割钢条"
subtitle:   "从切割钢条到背包问题"
date:       2016-10-08 16:00:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 算法
    - 动态规划
    - 算法导论
---

> 动态规划，从门外到门内


## 前言

这篇博客是博主的第一篇博客，之前是发表在CSDN上，现在把它整理过来。

---

## 正文

#### 原题

> 钢条切割问题出现在《算法导论》一书第204页，作为动态规划的例题出现，该题内容如下 
> Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最佳的切割方案。假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。钢条的长度均为整英寸。图15-1给出了一个价格表的样例。 
> ![这里写图片描述](http://images.cnitblog.com/blog2015/697266/201503/162025012825029.png) 
> 钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。

#### 程序第一版

程序主要利用动态规划的方法获取切取钢条的最大价值。

```java
//初级的钢条切割问题
public class CutBar1 {

    private static int bottomcutrod(int[] p, int n) {
        int[] r = new int[n + 1]; // 保存子问题的解
        r[0] = 0; // 底部第一个值初始化
        for (int j = 1; j <= n; j++) { // 自底向上
            int q = -1; // 初始最大价值，不可能为负价值
            for (int i = 1; i <= j; i++) {
                q = Math.max(q, p[i] + r[j - i]);// 相关子问题求解
            }
            r[j] = q;// 保存子问题的解
        }
        return r[n];// 返回所需解
    }

    public static void main(String[] args) {
        int p[] = { 0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 };
        System.out.println(bottomcutrod(p, 10));
    }

}
```

#### 程序第二版

改进的程序主要是增加了构造一个最优解的代码，在动态规划的第3个步骤中，是进行自底向上获得最优解，而通过一个表的存储就可以在获取最优解之后进行自顶向下构造最优解的方案。

```java
//增加最优解构造的钢条切割问题
public class CutBar2 {

    private static int bottomcutrod(int[] p, int n) {
        int[] r = new int[n + 1]; // 保存子问题的解
        int[] s = new int[n + 1]; // 保存最优解
        r[0] = 0; // 底部第一个值初始化
        for (int j = 1; j <= n; j++) { // 自底向上
            int q = -1; // 初始最大价值，不可能为负价值
            for (int i = 1; i <= j; i++) {
                if (q < p[i] + r[j - i]) {
                    q = p[i] + r[j - i];
                    s[j] = i;
                }
            }
            r[j] = q;// 保存子问题的解
        }
        int nn = n;
        while (nn > 0) {
            System.out.print(s[nn] + " ");
            nn = nn - s[nn];
        }
        return r[n];// 返回所需解
    }

    public static void main(String[] args) {
        int p[] = { 0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 };
        System.out.println(bottomcutrod(p, 10));
    }

}
```

#### 程序第三版

为了将钢条切割问题和背包问题结合起来，我对数据进行了改动，钢条的长度相当于背包的质量，可切割的钢条长度相当于可选择物品的质量，可切割钢条的价值相当于物品的价值，这里默认物品的数量无限，01背包问题在程序第四版中体现。为了让原题更接近于背包问题，我把原先具有价值的十个选择减少到了五个选择，并对一些代码进行改进，最后得到以下的代码。

```java
//将钢条问题完全转换为背包问题
public class CutBar3 {
    private static int n = 5;
    private static int weight[] = { 0, 1, 3, 5, 7, 9 };
    private static int value[] = { 0, 1, 8, 10, 17, 24 };

    private static int bottomcutrod(int w) {
        int[] r = new int[w + 1]; // 当背包质量为w时，r[w]为最大价值
        int[] s = new int[w + 1]; // 当背包质量为w时，s[w]为应放入的第一个物体
        r[0] = 0; // 当背包质量为0时,价值为0
        for (int j = 1; j <= w; j++) { // 枚举背包质量
            int q = -1; // 初始最大价值，不可能为负价值
            for (int i = 1; i <= n; i++) { // 枚举背包是否取第i件物品
                if (j - weight[i] < 0) { // 判断是否装得下
                    continue;
                }
                if (q < value[i] + r[j - weight[i]]) { // 判断是否选择该物品
                    q = value[i] + r[j - weight[i]];
                    s[j] = i;
                }
            }
            r[j] = q; // 保存背包质量为j时的最大价值
        }
        int w0 = w, k = 1; // 暂存提供背包质量
        while (w0 > 0) {
            System.out.println(k + "、放入第" + s[w0] + "个物品，其质量为" + weight[s[w0]] + "，价值为" + value[s[w0]] + "。");
            w0 = w0 - s[w0];
            k++;
        }
        return r[w];// 返回所需解
    }

    public static void main(String[] args) {
        System.out.println("总价值为" + bottomcutrod(10));
    }

}
```

#### 程序第四版

上面的程序是默认物品数量为无限，现在把情况限定为每种质量的物品只有一件，即为01背包问题，得到程序如下。

```java
//原背包问题完全转换为01背包问题
//源程序以背包的质量为元，只有背包的质量是独一无二的，故为一维问题，此处由于物品的选择和背包的质量一样，是独一无二的，所以有两个变量，是二维问题
public class CutBar4 {
    private static int n = 5;
    private static int w = 10;
    private static int weight[] = { 0, 1, 3, 5, 7, 9 };
    private static int value[] = { 0, 1, 8, 10, 17, 24 };

    private static int bottomcutrod() {
        int[][] r = new int[n + 1][w + 1]; // 当背包质量为w,物品为前n个时，r[n][w]为最大价值
        for (int i = 1; i <= n; i++) { // 枚举物品
            for (int j = 1; j <= w; j++) { // 枚举背包质量
                r[i][j] = r[i - 1][j]; // 初始化未取第i件物品时的值
                if (j >= weight[i]) { // 判断是否装得下
                    r[i][j] = Math.max(r[i - 1][j], r[i - 1][j - weight[i]] + value[i]);
                }
            }
        }
        return r[n][w];// 返回所需解
    }

    public static void main(String[] args) {
        System.out.println("总价值为" + bottomcutrod());
    }

}
```

#### 程序第五版

刚才的代码并没有对其中一个最优解进行保存，所以以下程序通过一个二维表对最优解进行保存，最后通过自顶向下的方法展示最优解。到此便是我根据钢条问题的编程实践和个人理解，欢迎大家指点批评。

```java
//原背包问题完全转换为01背包问题
//源程序以背包的质量为元，只有背包的质量是独一无二的，故为一维问题，此处由于物品的选择和背包的质量一样，是独一无二的，所以有两个变量，是二维问题
public class CutBar5 {
    private static int n = 5;
    private static int w = 10;
    private static int weight[] = { 0, 1, 3, 5, 7, 9 };
    private static int value[] = { 0, 1, 9, 10, 17, 24 };

    private static int bottomcutrod() {
        int[][] r = new int[n + 1][w + 1]; // 当背包质量为w,物品为前n个时，r[n][w]为最大价值
        int[][] s = new int[n + 1][w + 1]; // 当背包质量为w时，s[n][w]表示是否取第i个物品
        for (int i = 1; i <= n; i++) { // 枚举物品
            for (int j = 1; j <= w; j++) { // 枚举背包质量
                r[i][j] = r[i - 1][j]; // 初始化未取第i件物品时的值
                if (j >= weight[i]) { // 判断是否装得下
                    if (r[i - 1][j] < r[i - 1][j - weight[i]] + value[i]) { // 判断取不取这件物品
                        r[i][j] = r[i - 1][j - weight[i]] + value[i];
                        s[i][j] = 1;
                    }
                }
            }
        }
        // 二维问题用二元进行控制，自顶向下进行输出
        int n0 = n, w0 = w, k = 1;
        while (w0 > 0 && n0 > 0) {
            if (s[n0][w0] == 1) {
                System.out.println(k + "、放入第" + n0 + "个物品，其质量为" + weight[n0] + "，价值为" + value[n0] + "。");
                w0 = w0 - weight[n0];
                k++;
            } else {
                n0 = n0 - 1;
            }
        }
        return r[n][w];// 返回所需解
    }

    public static void main(String[] args) {
        System.out.println("总价值为" + bottomcutrod());
    }

}
```

## 后记

现在看之前的这篇博客，确实很稚嫩。从第一篇博客（2016年5月5日发布）到现在，虽然自己好有很多路要走，但这5个月的时间内也可以清楚认识到自己的进步，认识到博客的重要性。从劳动节到国庆节，希望在接下来从国庆节到劳动节的这个阶段内有更大的进步，等明年劳动节我再回来这里看看，看看曾经的自己。