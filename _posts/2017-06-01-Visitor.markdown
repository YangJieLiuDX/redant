---
layout:     post
title:      "设计模式之访问者模式"
subtitle:   "最后一个设计模式"
date:       2017-06-01 17:45:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 设计模式
---

> 天下没有不散的筵席
>


## 前言

转眼间已经来到这个系列的最后一篇文章了，而这篇文章的主题便是访问者模式。

---

## 正文

**什么是访问者模式**

在访问者模式中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。访问者模式包括以下角色：

- Vistor：抽象访问者。为对象结构中每一个具体元素类声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作
- ConcreteVisitor：具体访问者。实现了每个由抽象访问者声明的操作，每个操作用于访问对象结构中一种类型的元素
- Element：抽象元素。定义一个accept方法，该方法通常以一个抽象访问者作为参数
- ConcreteElement：具体元素。实现了accept方法，在accept方法中调用访问者的访问方法以完成对一个元素的操作
- ObjectStructure：对象结构、元素集合，用于存放元素对象，并提供遍历内部元素的方法

**怎么使用访问者模式**

***步骤一：创建Vistor***

```java
package com.visitor;

public interface ComputerPartVisitor {
	public void visit(Computer computer);

	public void visit(Mouse mouse);

	public void visit(Keyboard keyboard);

	public void visit(Monitor monitor);
}
```

***步骤二：创建ConcreteVisitor***

```java
package com.visitor;

public class ComputerPartDisplayVisitor implements ComputerPartVisitor {

	@Override
	public void visit(Computer computer) {
		System.out.println("Displaying Computer.");
	}

	@Override
	public void visit(Mouse mouse) {
		System.out.println("Displaying Mouse.");
	}

	@Override
	public void visit(Keyboard keyboard) {
		System.out.println("Displaying Keyboard.");
	}

	@Override
	public void visit(Monitor monitor) {
		System.out.println("Displaying Monitor.");
	}
}
```

***步骤三：创建Element***

```java
package com.visitor;

public interface ComputerPart {
	public void accept(ComputerPartVisitor computerPartVisitor);
}
```

***步骤四：创建ConcreteElement***

Keyboard类：

```java
package com.visitor;

public class Keyboard implements ComputerPart {

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		computerPartVisitor.visit(this);
	}
}
```

Monitor类：

```java
package com.visitor;

public class Monitor implements ComputerPart {

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		computerPartVisitor.visit(this);
	}
}
```

Mouse类：

```java
package com.visitor;

public class Mouse implements ComputerPart {

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		computerPartVisitor.visit(this);
	}
}
```

***步骤五：创建ObjectStructure***

```java
package com.visitor;

public class Computer implements ComputerPart {

	ComputerPart[] parts;

	public Computer() {
		parts = new ComputerPart[] { new Mouse(), new Keyboard(), new Monitor() };
	}

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		for (int i = 0; i < parts.length; i++) {
			parts[i].accept(computerPartVisitor);
		}
		computerPartVisitor.visit(this);
	}
}
```

***步骤六：创建Client***

```java
package com.visitor;

public class Client {
	public static void main(String[] args) {

		ComputerPart computer = new Computer();
		computer.accept(new ComputerPartDisplayVisitor());
	}
}
```

**访问者模式有哪些优缺点**

***优点***

- 符合单一职责原则
- 优秀的扩展性
- 灵活性


***缺点***

- 具体元素对访问者公布细节，违反了迪米特原则
- 具体元素变更比较困难
- 违反了依赖倒置原则，依赖了具体类，没有依赖抽象



**访问者模式适用于什么环境**

- 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类


## 后记

终于到了说再见的时候，这一系列文章的终结也意味着这学期快要结束了，最近在考研和工作两件事上没有找到平衡，接下来是时候调整心态与计划，在下学期做一个冲刺了！深知这一系列的文章还欠缺一点水准，接下来也会通过自己的学习不断完善。
