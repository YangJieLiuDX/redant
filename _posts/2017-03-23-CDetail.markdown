---
layout:     post
title:      "C语言的细枝末节"
subtitle:   "献给至始至终的C语言"
date:       2017-03-23 15:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - C
---

> 不定期更新的C语言笔记~~


## 前言

C语言是进入大学之后第一个接触的编程语言，虽然过了三年，但对它的喜爱丝毫不减，今天就通过这篇文章，讲讲关于C语言的一些知识点。

---

## 正文

**C语言中有bool变量吗**

C语言在C99标准之前是没有布尔变量的，而在C99标准中只要导入stdbool.h就可以使用bool变量。

**C语言中变量的默认类型是signed还是unsigned**

C语言中除了char类型，编译器默认其他整型都是signed，在x86的gcc平台上包括char在内所有整型都是signed。

**C语言必须初始化变量吗**

1. 如果变量不是自动变量，则只能进行一次初始化操作。在函数外部定义的变量或者在函数内部用static关键字定义的变量，在没有明确地被程序初始化之前都已被系统初始化为0了
2. 如果变量是自动变量，则必须在使用前进行赋值，否则它们就会具有未定义值
3. 调用malloc函数分配到的空间也包含未定义的数据，因此在使用它之前必须先进行初始化，但调用calloc()函数分配到的空间在分配时就已经被初始化为0了

**C语言自动类型转换的规则是怎样的**

回答这个问题之前，我们先来看一段代码：

```c
#include <stdio.h>

int main() {
    int x = -1;
    int array[] = {1, 2};
    if(x < sizeof(array)/sizeof(array[0])) {
        printf("true");
    }
}
```

以上的这段代码会输出什么呢？true？实际上不是的，这段程序将不会有任何输出，因为if语句中的判断失败了。sizeof函数的返回类型是无符号数，if语句在signed int和unsigned int之间测试相等性，所以x会自动转换为unsigned int类型，-1转换为unsigned int的结果将是一个非常巨大的正整数，致使表达式的值为假。《C专家编程》给出的建议是，尽可能不要在程序中使用无符号数，实际上，上面的这个例子也是从此书演化而来的。

那么究竟自动类型转换规则是怎样的呢？我们可以用下图说明一下：

![自动类型转换规则](/redant/img/c-autoconvert.png)

**C语言中怎么实现int类型和char *类型的相互转换**

int类型和char *类型的相互转换经常需要用到，特别是当我们用字符串来保存数值较大的数据时。

1. int转char *

   int转char *可以用到stdlib.h下的标准库函数itoa()，同理long转char *用到的是`ltoa()`等等。但实际上，itoa并不是一个标准C函数，它是Windows下特有的函数，与ANSI C不兼容，不利用程序的跨平台实现。所以，我们一般推荐使用的函数是`sprintf()`或`snprintf()`。

   `sprintf()`的使用案例如下：

   ```c
   char* buffer = ... allocate a buffer ...
   int value = 4564;
   sprintf(buffer, "%d", value);
   ```

   `snprintf()`的使用案例如下：

   ```c
   char buffer[10];
   int value = 234452;
   snprintf(buffer, 10, "%d", value);
   ```

   两者最主要的区别是后者可以通过设置最大字符数，保证缓存区不溢出。

2. char*转int

   这个使用的方法相对比较简单，与上面相似，就是用stdlib.h头文件中的`atoi()`函数，其他数据的转换方法相似。

**typedef int x[10]和#define x int[10]有什么区别**

表面看起来这两个表达式是等价的，其实不然，具体区别如下：

1. 可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做，如下代码：

   ```c
   #define peach int
   unsigned peach i; // 没问题
   typedef int banana;
   unsigned banana i; // 错误，非法
   ```

2. 在连续几个变量的声明中，用typedef定义的类型能够保证声明中所有变量均为同一种类型，而用#define定义的类型则无法保证，如下代码：

   ```c
   #define int_ptr int *
   // chalk为int*类型，cheese为int类型，下列语句相当于int * chalk, cheese;
   int_ptr chalk, cheese;
   typedef char * char_ptr;
   // Bentley和Rolls_Royce都是char*类型
   char_ptr Bentley, Rolls_Royce;
   ```

**函数能返回局部变量吗**

这个问题实际上分为以下两种情况：

1. 局部变量是基本类型，则可以返回局部变量，如下面代码输出a：

   ```c
   #include <stdio.h>

   char* get() {
       char i = 'a';
       return i;
   }

   int main() {
       printf("%c", get());
   }
   ```

2. 函数要返回一个指向该函数局部自动变量的指针，则会失败，具体如下：

   ```c
   #include <stdio.h>

   char* get() {
       char arr[] = 'apple';
       return arr;
   }

   int main() {
       printf("%s", get());
   }
   ```

   当进入此函数时，自动变量arr将在堆栈中分配，当函数结束后，变量不复存在，它所占用的堆栈控件被回收，指针失去了有效性，被称为悬垂指针。

**scanf函数的返回值有什么意义**

假设我们有一个程序，它的作用是算出输入的每一组数的和，具体如下：

```c
#include <stdio.h>

int main() {
    int num1, num2;
    while(1) {
        scanf("%d %d", &num1, &num2);
        printf("%d\n", num1 + num2);
    }
    return 0;
}
```

上面这个程序主要有两个问题：一是当我们想要退出循环的时候必须手动结束进程或者在循环体里面做一个判断；二是当输入的num1或num2不是指定的int类型的时候，程序就会出错。在这种情况下，我们可以用scanf函数的返回值来解决这个问题，具体如下：

```c
#include <stdio.h>

int main() {
    int num1, num2;
    while(scanf("%d %d", &num1, &num2) == 2) {
        printf("%d\n", num1 + num2);
    }
    return 0;
}
```

scanf函数的返回值为int类型，表示正确按指定格式输入变量的个数，即能正确接收到值的变量个数。运用到这一点我们就可以将第一段代码改进成以上代码，这样当输入不是int类型的值的时候就会退出循环了。

**C语言有提供排序函数吗**

C语言缺少很多库，因为它是一门面向于底层的语言，很多人把它当成教学上的第一门语言也是因为使用它能学到很多东西，很多功能都需要自己实现，除了[bsearch](https://man.cx/bsearch)和[qsort](https://man.cx/qsort)。

C语言中是存在排序函数的，即上面提到的qsort，它存在于stdlib.h头文件中，具体使用案例如下：

```c
#include <stdio.h>
#include <stdlib.h>
int s[10000], n, i;
int cmp(const void *a, const void *b) {
    return (*(int *)b - * (int *)a);
}
int main() {
    scanf("%d", &n);
    for(i = 0; i < n; i++)
        scanf("%d", &s[i]);
    qsort(s, n, sizeof(s[0]), cmp);
    for(i = 0; i < n; i++)
        printf("%d ", s[i]);
    return(0);
}
```

qsort函数传入的第四个参数是一个比较函数，决定了排序的规则，这里的规则是降序排列。

以上的方法是纯C语言支持的，实际上，在C++的algorithm库中，有一个sort函数，比qsort函数要高效很多，具体的理由可以查看stackoverflow上的[讨论](https://stackoverflow.com/questions/4708105/performance-of-qsort-vs-stdsort)。

**C语言怎么计算程序运算时间**

在Windows下，C语言计算程序运行时间需要用到time函数，下面是一个计算立方根迭代所需时间的例子：

```c
#include <stdio.h>
#include <time.h>

int main() {
    int x, n;
    scanf("%d %d", &x, &n);
    
    clock_t start, finish;
    double duration;
    start = clock();
    
    double y = x;
    int count = 0;
    while(count < n) {
        y = y * 2 / 3 + x / (3 * y * y);
        count++;
    }
    
    finish = clock();
    duration = (double)(finish - start) / CLOCKS_PER_SEC;
    printf( "%f seconds\n", duration );
    
    printf("%.6lf", y);
    return 0;
}
```

**C语言怎么获取随机数**

C语言取随机数的具体方法如下：

```c
#include <stdlib.h>
#include <time.h> 
/* 指定种子值为当前时间，以确保获取到的随机数不同 */
srand((unsigned)time(NULL));
for (int i=0; i<10; i++)
{
    printf("%d ", rand()%10);
}
```

**\*p++与(\*p)++有区别吗**

有，类似于\*和++这样的一员运算符遵循从右到左的结合顺序，具体可参考[C语言运算符优先级](http://en.cppreference.com/w/c/language/operator_precedence)。\*p++表示的是将指针移至下一地址并取其内容，而(\*p)++表示的是取指针内容并对其加一。

## 后记

C语言是一门很美妙的语言，本文也会随着本人经验的增长不定时更新。


