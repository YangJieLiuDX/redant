---
layout:     post
title:      "C语言的细枝末节"
subtitle:   "献给至始至终的C语言"
date:       2017-03-23 15:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - C
---

> 不定期更新的C语言笔记~~


## 前言

C语言是进入大学之后第一个接触的编程语言，虽然过了三年，但对它的喜爱丝毫不减，今天就通过这篇文章，讲讲关于C语言的一些知识点。

---

## 正文

**C语言中有bool变量吗**

C语言在C99标准之前是没有布尔变量的，而在C99标准中只要导入stdbool.h就可以使用bool变量。

**C语言中变量的默认类型是signed还是unsigned**

C语言中除了char类型，编译器默认其他整型都是signed，在x86的gcc平台上包括char在内所有整型都是signed。

**C语言必须初始化变量吗**

1. 如果变量不是自动变量，则只能进行一次初始化操作。在函数外部定义的变量或者在函数内部用static关键字定义的变量，在没有明确地被程序初始化之前都已被系统初始化为0了
2. 如果变量是自动变量，则必须在使用前进行赋值，否则它们就会具有未定义值
3. 调用malloc函数分配到的空间也包含未定义的数据，因此在使用它之前必须先进行初始化，但调用calloc()函数分配到的空间在分配时就已经被初始化为0了

**C语言自动类型转换的规则是怎样的**

回答这个问题之前，我们先来看一段代码：

```c
#include <stdio.h>

int main() {
    int x = -1;
    int array[] = {1, 2};
    if(x < sizeof(array)/sizeof(array[0])) {
        printf("true");
    }
}
```

以上的这段代码会输出什么呢？true？实际上不是的，这段程序将不会有任何输出，因为if语句中的判断失败了。sizeof函数的返回类型是无符号数，if语句在signed int和unsigned int之间测试相等性，所以x会自动转换为unsigned int类型，-1转换为unsigned int的结果将是一个非常巨大的正整数，致使表达式的值为假。《C专家编程》给出的建议是，尽可能不要在程序中使用无符号数，实际上，上面的这个例子也是从此书演化而来的。

那么究竟自动类型转换规则是怎样的呢？我们可以用下图说明一下：

![自动类型转换规则](/redant/img/c-autoconvert.png)

**C语言中怎么实现int类型和char *类型的相互转换**

int类型和char *类型的相互转换经常需要用到，特别是当我们用字符串来保存数值较大的数据时。

1. int转char *

   int转char *可以用到stdlib.h下的标准库函数itoa()，同理long转char *用到的是`ltoa()`等等。但实际上，itoa并不是一个标准C函数，它是Windows下特有的函数，与ANSI C不兼容，不利用程序的跨平台实现。所以，我们一般推荐使用的函数是`sprintf()`或`snprintf()`。

   `sprintf()`的使用案例如下：

   ```c
   char* buffer = ... allocate a buffer ...
   int value = 4564;
   sprintf(buffer, "%d", value);
   ```

   `snprintf()`的使用案例如下：

   ```c
   char buffer[10];
   int value = 234452;
   snprintf(buffer, 10, "%d", value);
   ```

   两者最主要的区别是后者可以通过设置最大字符数，保证缓存区不溢出。

2. char*转int

   这个使用的方法相对比较简单，与上面相似，就是用stdlib.h头文件中的`atoi()`函数，其他数据的转换方法相似。

**自增自减运算符的使用有没有限制**

回答这个问题之前，我们先来看一下几个关于自增自减运算符的表达式：

- 15++
- (x+y)--
- ++(a-b)
- s+++t+++u++

这几个表达式，哪些是正确的，哪些是错误的呢？这里我们只要了解一点就可以解决问题了，那就是自增自减运算符只能用于变量，而不能用于常量，所以上面的第一个、第二个以及第三个式子都是错误的。至于第四个式子，虽然是正确的，但是运算比较复杂，容易产生歧义，所以建议大家平时也不要这样使用自增自减运算符，这样的表达式也最好加上括号的辅助。

**typedef int x[10]和#define x int[10]有什么区别**

表面看起来这两个表达式是等价的，其实不然，具体区别如下：

1. 可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做，如下代码：

   ```c
   #define peach int
   unsigned peach i; // 没问题
   typedef int banana;
   unsigned banana i; // 错误，非法
   ```

2. 在连续几个变量的声明中，用typedef定义的类型能够保证声明中所有变量均为同一种类型，而用#define定义的类型则无法保证，如下代码：

   ```c
   #define int_ptr int *
   // chalk为int*类型，cheese为int类型，下列语句相当于int * chalk, cheese;
   int_ptr chalk, cheese;
   typedef char * char_ptr;
   // Bentley和Rolls_Royce都是char*类型
   char_ptr Bentley, Rolls_Royce;
   ```

**include "filename.h"和#include \<filename.h\>的区别是什么**

1. 带尖括号的头文件一般用于包含标准的库头文件，编译器会去系统配置的库环境变量或者用户配置的路径中搜索，而不会在当前的源文件目录中查找
2. 带双引号的头文件一般用于包含用户自己编写的头文件，编译器会先在当前的源文件目录中查找，找不到后才会去系统配置的库环境变量和用户配置的路径中搜索

**函数能返回局部变量吗**

这个问题实际上分为以下两种情况：

1. 局部变量是基本类型，则可以返回局部变量，如下面代码输出a：

   ```c
   #include <stdio.h>

   char* get() {
       char i = 'a';
       return i;
   }

   int main() {
       printf("%c", get());
   }
   ```

2. 函数要返回一个指向该函数局部自动变量的指针，则会失败，具体如下：

   ```c
   #include <stdio.h>

   char* get() {
       char arr[] = 'apple';
       return arr;
   }

   int main() {
       printf("%s", get());
   }
   ```

   当进入此函数时，自动变量arr将在堆栈中分配，当函数结束后，变量不复存在，它所占用的堆栈空间被回收，指针失去了有效性，被称为悬垂指针。

**scanf函数的返回值有什么意义**

假设我们有一个程序，它的作用是算出输入的每一组数的和，具体如下：

```c
#include <stdio.h>

int main() {
    int num1, num2;
    while(1) {
        scanf("%d %d", &num1, &num2);
        printf("%d\n", num1 + num2);
    }
    return 0;
}
```

上面这个程序主要有两个问题：一是当我们想要退出循环的时候必须手动结束进程或者在循环体里面做一个判断；二是当输入的num1或num2不是指定的int类型的时候，程序就会出错。在这种情况下，我们可以用scanf函数的返回值来解决这个问题，具体如下：

```c
#include <stdio.h>

int main() {
    int num1, num2;
    while(scanf("%d %d", &num1, &num2) == 2) {
        printf("%d\n", num1 + num2);
    }
    return 0;
}
```

scanf函数的返回值为int类型，表示正确按指定格式输入变量的个数，即能正确接收到值的变量个数。运用到这一点我们就可以将第一段代码改进成以上代码，这样当输入不是int类型的值的时候就会退出循环了。

**C语言有提供排序函数吗**

C语言缺少很多库，因为它是一门面向于底层的语言，很多人把它当成教学上的第一门语言也是因为使用它能学到很多东西，很多功能都需要自己实现，除了[bsearch](https://man.cx/bsearch)和[qsort](https://man.cx/qsort)。

C语言中是存在排序函数的，即上面提到的qsort，它存在于stdlib.h头文件中，具体使用案例如下：

```c
#include <stdio.h>
#include <stdlib.h>
int s[10000], n, i;
int cmp(const void *a, const void *b) {
    return (*(int *)b - * (int *)a);
}
int main() {
    scanf("%d", &n);
    for(i = 0; i < n; i++)
        scanf("%d", &s[i]);
    qsort(s, n, sizeof(s[0]), cmp);
    for(i = 0; i < n; i++)
        printf("%d ", s[i]);
    return(0);
}
```

qsort函数传入的第四个参数是一个比较函数，决定了排序的规则，这里的规则是降序排列。

以上的方法是纯C语言支持的，实际上，在C++的algorithm库中，有一个sort函数，比qsort函数要高效很多，具体的理由可以查看stackoverflow上的[讨论](https://stackoverflow.com/questions/4708105/performance-of-qsort-vs-stdsort)。

**C语言怎么计算一个整数的整数次幂**

这个问题主要有以下几种方法：

1. 直接用乘号计算，如2的3次方，计算过程是 2\*2\*2 ，这种方法适用于幂值较小的情况
2. 利用循环。如果幂值较大，则使用乘号工作量较大，所以可以使用循环实现连乘
3. 使用pow函数。在C语言的math.h头文件中，有一个pow函数，用来计算幂值。可是这个函数主要针对的数据类型是double类型，如果用来计算int类型，可能会存在一定偏差，所以需要适当的改进，改进的方法是将pow函数返回值加0.5之后再转为int类型，即`(int) (pow(10, 2) + 0.5))`。
4. 以上的方法都比较简单，如果需要更高的效率来进行求幂的话，可以参考[这里](https://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int)。

**C语言怎么计算程序运算时间**

在Windows下，C语言计算程序运行时间需要用到time函数，下面是一个计算立方根迭代所需时间的例子：

```c
#include <stdio.h>
#include <time.h>

int main() {
    int x, n;
    scanf("%d %d", &x, &n);
    
    clock_t start, finish;
    double duration;
    start = clock();
    
    double y = x;
    int count = 0;
    while(count < n) {
        y = y * 2 / 3 + x / (3 * y * y);
        count++;
    }
    
    finish = clock();
    duration = (double)(finish - start) / CLOCKS_PER_SEC;
    printf( "%f seconds\n", duration );
    
    printf("%.6lf", y);
    return 0;
}
```

**C语言怎么获取随机数**

C语言取随机数的具体方法如下：

```c
#include <stdlib.h>
#include <time.h> 
/* 指定种子值为当前时间，以确保获取到的随机数不同 */
srand((unsigned)time(NULL));
for (int i=0; i<10; i++)
{
    printf("%d ", rand()%10);
}
```

**指针占用内存的大小由什么决定**

这个问题的来源是北航的一道考题：字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？一开始我觉得三者是不一样大的，查了一番资料，我才知道是一样大的。那具体是为什么呢？

首先我们先看一下以下几组正确数据：

1. 32位处理器上32位操作系统的32位编译器，指针大小4字节
2. 32位处理器上32位操作系统的16位编译器，指针大小2字节
3. 32位处理器上16位操作系统的16位编译器，指针大小2字节
4. 16位处理器上16位操作系统的16位编译器，指针大小2字节

从这几组数据来看，指针的大小貌似由编译器决定。但实际不是这样的，有这样的结果，是因为处理器当前运行模式的寻址位数是不一样的。编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果编译器支持32位的CPU，那么它就可以将源程序编译为可在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数编译选择为4字节。

综上可得：指针大小跟硬件相关，是由当前CPU运行模式的寻址位数决定的。在同一环境下，指针的大小都是一样的。

**\*p++与(\*p)++有区别吗**

有，类似于\*和++这样的一员运算符遵循从右到左的结合顺序，具体可参考[C语言运算符优先级](http://en.cppreference.com/w/c/language/operator_precedence)。\*p++表示的是将指针移至下一地址并取其内容，而(\*p)++表示的是取指针内容并对其加一。

**int (\*p)[n]与int \*p[n]有什么区别**

首先我们先看一下题目中出现的三个符号的优先级比较：`()>[]>*`。接着我们再来比较一下两个表达的区别。

int (\*p)[n]是一个数组指针，也称行指针。()优先级高，说明p是个指针，指向一个整型的一维数组，数组长度是n，也可以说是p的步长。所以执行`p+1`时，p要跨过n个整型数据的长度。这也是数组指针被叫做行指针的原因。

int \*p[n]则是一个指针数组。[]优先级高，与p结合成一个数组，再由int\*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行`p+1`是错误的，`p=a`的赋值方式也是错误的。但可以这样：`*p=a`，这里\*p表示指针数组第一个元素的值，a的首地址的值。

**数组的初始化和赋值有什么区别吗**

首先我们先看两段代码：

```c
// 1
char a[10] = "Hello";
// 2
char a[10];
a = "Hello";
```

接下来，我们再思考一个问题，这上面的两段代码等价吗？可能会有人给出肯定的答案，但实际上是不等价的。第一段代码的操作，我们叫做初始化（initialization），它属于正常的数组初始化操作，并没有任何问题。而后一段代码实际上是赋值（assignment）操作，它会出现编译错误，具体的原因有两种解释。第一种解释是a实际上是一个常量，它代表数组地址即第一个元素的地址，而我们不能对一个常量进行赋值。另一种解释则是从编译器给出的错误信息出发，在编译器中出现的错误信息为：assignment to expression with array type。而根据C11标准中的章节6.5.16可得：

> assignment operator shall have a modifiable lvalue as its left operand.

再根据6.3.2.1的内容

> A modifiable lvalue is an lvalue that does not have array type, [...]

综合以上，我们可以知道a是不能被赋值的。

**数组名可以使用自增自减运算符吗**

这个问题实际上与上一个问题有点相似，答案是不可以。我们先看一段代码：

```c
int a[10];
a++;
```

正如我们已经给出的回答一样，上面的这段代码会出现编译错误，因为数组名是地址常量，所以不可作为左值，也就不可以自增。那么如果我们把`a++`改成`a + 1`，会出现编译错误吗？答案是不会，可是这个表达式实际上的意思就是a的地址值加上1的结果，而不是a[1]的值。同样的，`a = a + 1`也会出现编译错误。

接下来我们再看一段代码：

```c
int a[10];
int *p = a;
p++;
```

这段代码会不会编译错误呢？不会，因为这里的p是一个存放地址的变量，所以可以作为左值，也就可以自增。

**memset函数可以用来初始化int数组吗**

memset函数按**字节**对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的值。例如`memset(a, 1, 20)`，就是对a指向的内存的20个字节进行赋值，每个都用数1去填充，转为二进制后，1就是00000001，占一个字节。一个int元素是4字节，合一起是0000 0001,0000 0001,0000 0001,0000 0001，转化成十六进制就是0x01010101，就等于16843009，就完成了对一个int元素的赋值了。

**结构体的点运算符和箭头运算符有什么区别**

这两个运算符都是二元操作符，且右边的操作数都是成员的名称。两者的主要区别是点运算符的左边操作数是一个结果为结构的表达式，而箭头运算符左边的操作数是一个指向结构体的指针。

## 后记

C语言是一门很美妙的语言，本文也会随着本人经验的增长不定时更新。


