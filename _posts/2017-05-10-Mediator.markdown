---
layout:     post
title:      "设计模式之中介者模式"
subtitle:   "助人为乐的设计模式"
date:       2017-05-10 20:30:00
author:     "林佩勤"
header-img: "img/post-bg.jpg"
tags:
    - 设计模式
---

> 胸前的红领巾更加鲜艳了~~~
>


## 前言

中介在我们的生活中到处可见，就连在我们的软件世界里也可以看到它的身影，今天就让我们来学习一下设计模式里的中介者模式！

---

## 正文

**什么是中介者模式**

中介者模式值得是用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式包括以下角色：

- Mediator：中介者。定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信
- ConcreteMediator：具体中介者。从抽象中介者继承而来，实现抽象中介者中定义的事件方法。
- Colleague Class：同事类。如果一个对象会影响其他对象，同时也会被其他对象影响，那么这两个对象称为同事类。在中介者模式中，同事类之间必须通过中介者才能进行消息传递

**怎么使用中介者模式**

***步骤一：创建Mediator***

```java
package com.mediator;

public abstract class Mediator {
	public abstract void constact(String message, Person person);
}
```

***步骤二：创建ConcreteMediator***

```java
package com.mediator;

public class MediatorStructure extends Mediator {

	private HouseOwner houseOwner;
	private Tenant tenant;

	public HouseOwner getHouseOwner() {
		return houseOwner;
	}

	public void setHouseOwner(HouseOwner houseOwner) {
		this.houseOwner = houseOwner;
	}

	public Tenant getTenant() {
		return tenant;
	}

	public void setTenant(Tenant tenant) {
		this.tenant = tenant;
	}

	public void constact(String message, Person person) {
		if (person == houseOwner) {
			tenant.getMessage(message);
		} else {
			houseOwner.getMessage(message);
		}
	}
}
```

***步骤三：创建抽象同事类***

```java
package com.mediator;

public abstract class Person {
	
	protected String name;
	protected Mediator mediator;

	Person(String name, Mediator mediator) {
		this.name = name;
		this.mediator = mediator;
	}

}
```

***步骤四：创建具体同事类***

HouseOwner类：

```java
package com.mediator;

public class HouseOwner extends Person {

	HouseOwner(String name, Mediator mediator) {
		super(name, mediator);
	}

	public void constact(String message) {
		mediator.constact(message, this);
	}

	public void getMessage(String message) {
		System.out.println("房主:" + name + ",获得信息：" + message);
	}
}
```

Tenant类：

```java
package com.mediator;

public class Tenant extends Person {

	Tenant(String name, Mediator mediator) {
		super(name, mediator);
	}

	public void constact(String message) {
		mediator.constact(message, this);
	}

	public void getMessage(String message) {
		System.out.println("租房者:" + name + ",获得信息：" + message);
	}

}
```

***步骤五：创建Client***

```java
package com.mediator;

public class Client {

	public static void main(String[] args) {
		MediatorStructure mediator = new MediatorStructure();
		HouseOwner houseOwner = new HouseOwner("张三", mediator);
		Tenant tenant = new Tenant("李四", mediator);
		mediator.setHouseOwner(houseOwner);
		mediator.setTenant(tenant);
		tenant.constact("听说你那里有三室的房主出租.....");
		houseOwner.constact("是的!请问你需要租吗?");
	}

}
```

**中介者模式有哪些优缺点**

***优点***

- 简化对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使系统成为松耦合系统
- 减少了子类的生成
- 可以减少各同事类的设计与实现

***缺点***

- 由于中介者对象封装了系统中对象之间的相互关系，导致其变得非常复杂，使得系统维护比较困难


**迭代器模式适用于什么环境**

- 系统中对象之间存在比较复杂的引用关系，导致他们之间的依赖关系结构混乱且难以复用该对象
- 想通过一个中间类封装多个类中的行为，而又不想生成太多子类


## 后记

一个晚上赶完了几篇文章，质量上也有待改进，随着学习的深入，我也会不断地完善这些文章。
